{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"TBRU microbiome data analysis page What is the Tri-I TBRU? The NIH/National Institute of Allergy and Infectious Diseases TBRU program funds multi-disiplinary, collaborative, benchside-to-bedside research aimed at understanding the biology of host-pathogen interactions within the context of the clinic. The Tri-I TBRU is a multi year study conducted in Haiti and New York City aimed at understanding the incrediably complex relationsips between humans and one of the most exquisitely evolved human pathogens, Mycobacterium tuberculosis . Check out our most recent papers! Mucosal-associated invariant and \u03b3\u03b4 T cell subsets respond to initial Mycobacterium tuberculosis infection JCI Insight, 2018 doi: 10.1172/jci.insight.121899 Antibiotic treatment for Tuberculosis induces a profound dysbiosis of the microbiome that persists long after therapy is completed Scientific Reports 7, Article number: 10767 (2017) doi: 10.1038/s41598-017-10346-6 News coverage from Weill Cornell Medicine This work was generously funded by the following NIH grants: --Tri-Institutional TB Research Unit: Persistence and Latency: Grant ID U19 AI111143, National Institute of Allergy and Infectious Diseases Extramural Activities --J NRSA Training Core: Grant ID TL1 TR002386, National Center for Advancing Translational Sciences --Clinical and Translational Science Center: Grant ID UL1 TR000457, National Center for Advancing Translational Sciences","title":"Home"},{"location":"#tbru-microbiome-data-analysis-page","text":"","title":"TBRU microbiome data analysis page"},{"location":"#what-is-the-tri-i-tbru","text":"The NIH/National Institute of Allergy and Infectious Diseases TBRU program funds multi-disiplinary, collaborative, benchside-to-bedside research aimed at understanding the biology of host-pathogen interactions within the context of the clinic. The Tri-I TBRU is a multi year study conducted in Haiti and New York City aimed at understanding the incrediably complex relationsips between humans and one of the most exquisitely evolved human pathogens, Mycobacterium tuberculosis .","title":"What is the Tri-I TBRU?"},{"location":"#check-out-our-most-recent-papers","text":"","title":"Check out our most recent papers!"},{"location":"#mucosal-associated-invariant-and-t-cell-subsets-respond-to-initial-mycobacterium-tuberculosis-infection","text":"","title":"Mucosal-associated invariant and \u03b3\u03b4 T cell subsets respond to initial Mycobacterium tuberculosis infection"},{"location":"#jci-insight-2018","text":"doi: 10.1172/jci.insight.121899","title":"JCI Insight, 2018"},{"location":"#antibiotic-treatment-for-tuberculosis-induces-a-profound-dysbiosis-of-the-microbiome-that-persists-long-after-therapy-is-completed","text":"","title":"Antibiotic treatment for Tuberculosis induces a profound dysbiosis of the microbiome that persists long after therapy is completed"},{"location":"#scientific-reports-7-article-number-10767-2017","text":"doi: 10.1038/s41598-017-10346-6 News coverage from Weill Cornell Medicine This work was generously funded by the following NIH grants: --Tri-Institutional TB Research Unit: Persistence and Latency: Grant ID U19 AI111143, National Institute of Allergy and Infectious Diseases Extramural Activities --J NRSA Training Core: Grant ID TL1 TR002386, National Center for Advancing Translational Sciences --Clinical and Translational Science Center: Grant ID UL1 TR000457, National Center for Advancing Translational Sciences","title":"Scientific Reports 7, Article number: 10767 (2017)"},{"location":"Cured/","text":"HRZE causes dysbiosis This tutorial is a walkthrough of the data analysis from: Antibiotic treatment for Tuberculosis induces a profound dysbiosis of the microbiome that persists long after therapy is completed Scientific Reports 7, Article number: 10767 (2017) doi: 10.1038/s41598-017-10346-6 It shows how to take microbiome data and reproduce the figures from this paper. Jump right to subsetting... See the previous section (Treatment) for how to generate the Phyloseq object #IGRA positive vs cured (IGRA+ vs cured) phy_pos_cured - subset_samples(phy,!is.na(IGRA) IGRA!= negative ) phy_pos_cured - subset_samples(phy_pos_cured,!is.na(IGRA) IGRA!= ) phy_pos_cured - subset_samples(phy_pos_cured,!is.na(TB_status) TB_status!= treatment ) phy_pos_cured - subset_samples(phy_pos_cured,!is.na(Group6_TB_category) Group6_TB_category!= family_contact ) phy_pos_cured - subset_samples(phy_pos_cured,!is.na(Group6_TB_category) Group6_TB_category!= treatment ) phy_pos_cured - subset_samples(phy_pos_cured, age 30) #Variance of OTU abundances hist(log10(apply(otu_table(phy_pos_cured), 1, var)), xlab = log10(variance) , main = Variance distribution for LTBI/Cured ) DESeq normalization library( DESeq2 ) phy_DESeq - phy_pos_cured t - get.tax(phy_DESeq) % % mutate(PhySpec=paste(Species,otu)) taxa_names(phy_DESeq) - t$PhySpec taxa_names(phy_DESeq) - gsub( , _ ,taxa_names(phy_DESeq)) taxa_names(phy_DESeq) - gsub( = , _ ,taxa_names(phy_DESeq)) taxa_names(phy_DESeq) - gsub( ; , _ ,taxa_names(phy_DESeq)) dig - phyloseq_to_deseq2(phy_DESeq, ~ TB_status) #replace this with any sample variable(s) #calculate geometric mean gm_mean - function(x, na.rm=TRUE){ exp(sum(log(x[x 0]), na.rm=na.rm) / length(x)) } geoMeans - apply(counts(dig), 1, gm_mean) dig - estimateSizeFactors(dig, geoMeans = geoMeans) dig - estimateDispersions(dig) dig - DESeq(dig,fitType= local ) res - results(dig) #res$pfdr - p.adjust(res$pvalue,method= fdr ) res - res[order(res$padj, na.last=NA), ] alpha - 0.05 sigtab - res[(res$padj alpha), ] sigtab - cbind(as(sigtab, data.frame ), as(tax_table(phy_DESeq)[rownames(sigtab), ], matrix )) head(sigtab) #view the data posigtab - sigtab[sigtab[, log2FoldChange ] 1, ] posigtab - posigtab[, c( baseMean , log2FoldChange , lfcSE , padj , Phylum , Class , Family , Genus )] DESeq normalization plots library( ggplot2 ) theme_set(theme_bw()) sigtabgen - subset(sigtab, !is.na(Genus)) sigtabgen - subset(sigtab, !is.na(Phylum)) # Phylum order x - tapply(sigtabgen$log2FoldChange, sigtabgen$Phylum, function(x) max(x)) x - sort(x, TRUE) sigtabgen$Phylum = factor(as.character(sigtabgen$Phylum), levels=names(x)) # Genus order x - tapply(sigtabgen$log2FoldChange, sigtabgen$Genus, function(x) max(x)) x - sort(x, TRUE) sigtabgen$Genus - factor(as.character(sigtabgen$Genus), levels=names(x)) phylumcolors - c( hotpink , brown , lightblue , purple ) ggplot(sigtabgen, aes(x = Genus, y = log2FoldChange, color = Phylum)) + geom_point(size = 6) + theme(axis.text.x = element_text(angle = -45, hjust = 0, vjust = 1)) + theme(axis.text=element_text(size=12,face= bold ),legend.text=element_text(size=12)) Run LEfSE for LTBI vs Cured phy.lefse - phy_DESeq results_folder - ~/Desktop/uparse_july/ class - TB_status subclass -FALSE subject - sample anova.alpha -0.05 wilcoxon.alpha -0.05 lda.cutoff -2.5 wilcoxon.within.subclass - TRUE one.against.one - T mult.test.correction - 0 make.lefse.plots - FALSE by_otus - FALSE # sample.data - phyloseq::sample_data(phy.lefse) % % data.frame(stringsAsFactors = FALSE) sample.data$sample - rownames(sample.data) # keepvars - c( sample , TB_status ) keepvars - unique(keepvars[!is.na(keepvars)]) lefse.samp - sample.data[, keepvars] # sample0 - t(lefse.samp) % % as.matrix() colnames(sample0) - sample0[1,] sample0 - as.data.frame(sample0) # data0 - otu_table(phy.lefse) % % as.data.frame() data1 - data0 % % as.data.table(keep.rownames=T) sample1 - sample0 % % as.data.table(keep.rownames=T) common - intersect(colnames(data1), colnames(sample1)) pre.lefse - rbind(sample1, data1,fill=T) % % t() % % na.omit() % % t() #writes table for LEfSe write.table(pre.lefse,file =paste(results_folder, lefse.txt ,sep= ),sep = \\t ,row.names = FALSE,col.names = FALSE,quote = FALSE) opt.class - paste( -c , which(keepvars %in% class)) opt.subclass - ifelse(is.na(subclass), , paste( -s , which(keepvars %in% subclass))) opt.subject - ifelse(is.na(subject), , paste( -u , which(keepvars %in% subject))) format.command - paste(paste( format_input.py ,results_folder, lefse.txt ,results_folder, lefse.in ,sep= ), opt.class, opt.subject, -o 1000000 ) format.command # format_input.py ~/Desktop/uparse_july/lefse.txt ~/Desktop/uparse_july/lefse.in -c 2 -u 1 -o 1000000 system(format.command) lefse.command - paste(paste( ~/miniconda2/bin/python ~/lefse/run_lefse.py ,results_folder, lefse.in ,results_folder, lefse.res ,sep= ), -a , anova.alpha, -w , wilcoxon.alpha, -l , lda.cutoff, -e , as.numeric(wilcoxon.within.subclass), -y , as.numeric(one.against.one), -s , mult.test.correction) lefse.command # ~/miniconda2/bin/python ~/lefse/run_lefse.py ~/Desktop/uparse_july/lefse.in ~/Desktop/uparse_july/lefse.res -a 0.05 -w 0.05 -l 3 -e 1 -y 1 -s 0 system(lefse.command) #this will print out the number of significant OTUs (make sure it's not 0) lefse.out - read.table(paste(results_folder, lefse.res ,sep= ), header = FALSE, sep = \\t ) names(lefse.out) -c( taxon , log.max.pct , direction , lda , p.value ) (lefse.out -na.omit(lefse.out)) Palette_LTBI_cured - c( #e7298a , #377eb8 ) if(length(unique(lefse.out$direction)) 3){ lefse.out$lda[lefse.out$direction==unique(lefse.out$direction)[1]] - -1*lefse.out$lda[lefse.out$direction==unique(lefse.out$direction)[1]] } lefse.out$taxon -factor(lefse.out$taxon,levels=lefse.out$taxon[order(lefse.out$lda)]) g1 -ggplot(data=lefse.out,aes(x=taxon,y=lda,color=direction,fill=direction))+ geom_bar(stat= identity )+ coord_flip()+ theme_base() if(length(unique(lefse.out$direction)) 3){ g1 -g1+scale_color_manual(values=c(Palette_LTBI_cured))+ scale_fill_manual(values=c(Palette_LTBI_cured)) } print(g1) ltk -as.character(lefse.out$taxon) phy_ra_ltk -prune_taxa(ltk,phy.lefse) phy_ra_ltk_m -psmelt(phy_ra_ltk) phy_ra_ltk_m$OTU -factor(phy_ra_ltk_m$OTU, levels=lefse.out$taxon[order(lefse.out$lda)]) g2 -ggplot(phy_ra_ltk_m,aes(x=Genus, y=Abundance,color=TB_status, fill=TB_status))+ geom_boxplot(position=position_dodge(), colour= black , # Use black outlines, size=.3,alpha=0.5) + # Thinner lines theme_base()+ xlab( )+ coord_flip() + scale_y_continuous(limits = c(0,300)) if(length(unique(lefse.out$direction)) 3){ g2 -g2+scale_color_manual(values=c(Palette_LTBI_cured))+ scale_fill_manual(values=c(Palette_LTBI_cured)) } print(g2) Figure 4D from paper","title":"Cured"},{"location":"Cured/#hrze-causes-dysbiosis","text":"This tutorial is a walkthrough of the data analysis from: Antibiotic treatment for Tuberculosis induces a profound dysbiosis of the microbiome that persists long after therapy is completed Scientific Reports 7, Article number: 10767 (2017) doi: 10.1038/s41598-017-10346-6 It shows how to take microbiome data and reproduce the figures from this paper.","title":"HRZE causes dysbiosis"},{"location":"Cured/#jump-right-to-subsetting","text":"See the previous section (Treatment) for how to generate the Phyloseq object #IGRA positive vs cured (IGRA+ vs cured) phy_pos_cured - subset_samples(phy,!is.na(IGRA) IGRA!= negative ) phy_pos_cured - subset_samples(phy_pos_cured,!is.na(IGRA) IGRA!= ) phy_pos_cured - subset_samples(phy_pos_cured,!is.na(TB_status) TB_status!= treatment ) phy_pos_cured - subset_samples(phy_pos_cured,!is.na(Group6_TB_category) Group6_TB_category!= family_contact ) phy_pos_cured - subset_samples(phy_pos_cured,!is.na(Group6_TB_category) Group6_TB_category!= treatment ) phy_pos_cured - subset_samples(phy_pos_cured, age 30) #Variance of OTU abundances hist(log10(apply(otu_table(phy_pos_cured), 1, var)), xlab = log10(variance) , main = Variance distribution for LTBI/Cured )","title":"Jump right to subsetting..."},{"location":"Cured/#deseq-normalization","text":"library( DESeq2 ) phy_DESeq - phy_pos_cured t - get.tax(phy_DESeq) % % mutate(PhySpec=paste(Species,otu)) taxa_names(phy_DESeq) - t$PhySpec taxa_names(phy_DESeq) - gsub( , _ ,taxa_names(phy_DESeq)) taxa_names(phy_DESeq) - gsub( = , _ ,taxa_names(phy_DESeq)) taxa_names(phy_DESeq) - gsub( ; , _ ,taxa_names(phy_DESeq)) dig - phyloseq_to_deseq2(phy_DESeq, ~ TB_status) #replace this with any sample variable(s) #calculate geometric mean gm_mean - function(x, na.rm=TRUE){ exp(sum(log(x[x 0]), na.rm=na.rm) / length(x)) } geoMeans - apply(counts(dig), 1, gm_mean) dig - estimateSizeFactors(dig, geoMeans = geoMeans) dig - estimateDispersions(dig) dig - DESeq(dig,fitType= local ) res - results(dig) #res$pfdr - p.adjust(res$pvalue,method= fdr ) res - res[order(res$padj, na.last=NA), ] alpha - 0.05 sigtab - res[(res$padj alpha), ] sigtab - cbind(as(sigtab, data.frame ), as(tax_table(phy_DESeq)[rownames(sigtab), ], matrix )) head(sigtab) #view the data posigtab - sigtab[sigtab[, log2FoldChange ] 1, ] posigtab - posigtab[, c( baseMean , log2FoldChange , lfcSE , padj , Phylum , Class , Family , Genus )]","title":"DESeq normalization"},{"location":"Cured/#deseq-normalization-plots","text":"library( ggplot2 ) theme_set(theme_bw()) sigtabgen - subset(sigtab, !is.na(Genus)) sigtabgen - subset(sigtab, !is.na(Phylum)) # Phylum order x - tapply(sigtabgen$log2FoldChange, sigtabgen$Phylum, function(x) max(x)) x - sort(x, TRUE) sigtabgen$Phylum = factor(as.character(sigtabgen$Phylum), levels=names(x)) # Genus order x - tapply(sigtabgen$log2FoldChange, sigtabgen$Genus, function(x) max(x)) x - sort(x, TRUE) sigtabgen$Genus - factor(as.character(sigtabgen$Genus), levels=names(x)) phylumcolors - c( hotpink , brown , lightblue , purple ) ggplot(sigtabgen, aes(x = Genus, y = log2FoldChange, color = Phylum)) + geom_point(size = 6) + theme(axis.text.x = element_text(angle = -45, hjust = 0, vjust = 1)) + theme(axis.text=element_text(size=12,face= bold ),legend.text=element_text(size=12))","title":"DESeq normalization plots"},{"location":"Cured/#run-lefse-for-ltbi-vs-cured","text":"phy.lefse - phy_DESeq results_folder - ~/Desktop/uparse_july/ class - TB_status subclass -FALSE subject - sample anova.alpha -0.05 wilcoxon.alpha -0.05 lda.cutoff -2.5 wilcoxon.within.subclass - TRUE one.against.one - T mult.test.correction - 0 make.lefse.plots - FALSE by_otus - FALSE # sample.data - phyloseq::sample_data(phy.lefse) % % data.frame(stringsAsFactors = FALSE) sample.data$sample - rownames(sample.data) # keepvars - c( sample , TB_status ) keepvars - unique(keepvars[!is.na(keepvars)]) lefse.samp - sample.data[, keepvars] # sample0 - t(lefse.samp) % % as.matrix() colnames(sample0) - sample0[1,] sample0 - as.data.frame(sample0) # data0 - otu_table(phy.lefse) % % as.data.frame() data1 - data0 % % as.data.table(keep.rownames=T) sample1 - sample0 % % as.data.table(keep.rownames=T) common - intersect(colnames(data1), colnames(sample1)) pre.lefse - rbind(sample1, data1,fill=T) % % t() % % na.omit() % % t() #writes table for LEfSe write.table(pre.lefse,file =paste(results_folder, lefse.txt ,sep= ),sep = \\t ,row.names = FALSE,col.names = FALSE,quote = FALSE) opt.class - paste( -c , which(keepvars %in% class)) opt.subclass - ifelse(is.na(subclass), , paste( -s , which(keepvars %in% subclass))) opt.subject - ifelse(is.na(subject), , paste( -u , which(keepvars %in% subject))) format.command - paste(paste( format_input.py ,results_folder, lefse.txt ,results_folder, lefse.in ,sep= ), opt.class, opt.subject, -o 1000000 ) format.command # format_input.py ~/Desktop/uparse_july/lefse.txt ~/Desktop/uparse_july/lefse.in -c 2 -u 1 -o 1000000 system(format.command) lefse.command - paste(paste( ~/miniconda2/bin/python ~/lefse/run_lefse.py ,results_folder, lefse.in ,results_folder, lefse.res ,sep= ), -a , anova.alpha, -w , wilcoxon.alpha, -l , lda.cutoff, -e , as.numeric(wilcoxon.within.subclass), -y , as.numeric(one.against.one), -s , mult.test.correction) lefse.command # ~/miniconda2/bin/python ~/lefse/run_lefse.py ~/Desktop/uparse_july/lefse.in ~/Desktop/uparse_july/lefse.res -a 0.05 -w 0.05 -l 3 -e 1 -y 1 -s 0 system(lefse.command) #this will print out the number of significant OTUs (make sure it's not 0) lefse.out - read.table(paste(results_folder, lefse.res ,sep= ), header = FALSE, sep = \\t ) names(lefse.out) -c( taxon , log.max.pct , direction , lda , p.value ) (lefse.out -na.omit(lefse.out)) Palette_LTBI_cured - c( #e7298a , #377eb8 ) if(length(unique(lefse.out$direction)) 3){ lefse.out$lda[lefse.out$direction==unique(lefse.out$direction)[1]] - -1*lefse.out$lda[lefse.out$direction==unique(lefse.out$direction)[1]] } lefse.out$taxon -factor(lefse.out$taxon,levels=lefse.out$taxon[order(lefse.out$lda)]) g1 -ggplot(data=lefse.out,aes(x=taxon,y=lda,color=direction,fill=direction))+ geom_bar(stat= identity )+ coord_flip()+ theme_base() if(length(unique(lefse.out$direction)) 3){ g1 -g1+scale_color_manual(values=c(Palette_LTBI_cured))+ scale_fill_manual(values=c(Palette_LTBI_cured)) } print(g1) ltk -as.character(lefse.out$taxon) phy_ra_ltk -prune_taxa(ltk,phy.lefse) phy_ra_ltk_m -psmelt(phy_ra_ltk) phy_ra_ltk_m$OTU -factor(phy_ra_ltk_m$OTU, levels=lefse.out$taxon[order(lefse.out$lda)]) g2 -ggplot(phy_ra_ltk_m,aes(x=Genus, y=Abundance,color=TB_status, fill=TB_status))+ geom_boxplot(position=position_dodge(), colour= black , # Use black outlines, size=.3,alpha=0.5) + # Thinner lines theme_base()+ xlab( )+ coord_flip() + scale_y_continuous(limits = c(0,300)) if(length(unique(lefse.out$direction)) 3){ g2 -g2+scale_color_manual(values=c(Palette_LTBI_cured))+ scale_fill_manual(values=c(Palette_LTBI_cured)) } print(g2) Figure 4D from paper","title":"Run LEfSE for LTBI vs Cured"},{"location":"Cured_metagenomics/","text":"Loading the data rm (list = ls()) library( phyloseq );library( ggplot2 );library( gridExtra );library( RColorBrewer );library( colorspace ); library( lattice );library( plyr );library( pracma );library( ggthemes );library( pheatmap );library( ComplexHeatmap ); library( BiocParallel );library( genefilter );library( DESeq2 );library( tidyr );library( viridis );library(data.table); library( KEGGREST ) setwd( ~/Desktop/metagenomics/Jan04_17_results ) register(MulticoreParam(30)) asinTransform - function(p) { asin(sqrt(p)) } mainDir - ../metagenomics/ subDir - metaphlan_profiling_cured dir.create(file.path(mainDir, subDir), showWarnings = TRUE, recursive = TRUE) results_folder - paste(mainDir,subDir,sep= ) mtph_subDir - metaphlan_profiling/ dir.create(file.path(mainDir, mtph_subDir), showWarnings = TRUE, recursive = TRUE) mtph_results_folder - paste(mainDir,mtph_subDir,sep= ) mtph_dat - read.csv( ../tbru_ss_data/metaphlan2_taxonomic_table_joined.tsv ,sep= \\t ) mtph -mtph_dat rownames(mtph) -mtph$X.SampleID mtph$X.SampleID -NULL mtph_otudata -otu_table(mtph,taxa_are_rows = TRUE) mtph_taxmat - matrix(sample(letters, nrow(mtph_otudata)/10, replace = TRUE), nrow = nrow(mtph_otudata), ncol = 7) rownames(mtph_taxmat) - rownames(mtph_otudata) colnames(mtph_taxmat) - c( Domain , Phylum , Class , Order , Family , Genus , Species ) mtph_taxmat -tax_table(mtph_taxmat) mtph_phy - phyloseq(mtph_otudata, mtph_taxmat) Import the metaphlan data to phyloseq metadata.file - ../tbru_ss_data/TBRU_Metadata_May2017.csv metadata - read.csv(metadata.file,na.strings=c( N/A , 99999 )) metadata[is.na(metadata)] - 99999 metadata$sample -gsub( - , . ,metadata$sample) samp - metadata % % data.frame() rownames(samp) -metadata$sample snames -as.data.frame(do.call('rbind',strsplit(sample_names(mtph_phy), _ )))[,1] sample_names(mtph_phy) -snames sample_data(mtph_phy) -samp # subsettings mtph_phy_pos_cured_no_treat -subset_samples(mtph_phy,!is.na(TB_status) TB_status!= treatment ) mtph_phy_pos_cured_no_treat - subset_samples(mtph_phy_pos_cured_no_treat,!is.na(Group6_TB_category) Group6_TB_category!= family_member ) # keep only 38 years old in age mtph_phy_pos_cured_no_treat - subset_samples(mtph_phy_pos_cured_no_treat,age =38) sample_data(mtph_phy_pos_cured_no_treat)$TB_status - relevel(sample_data(mtph_phy_pos_cured_no_treat)$TB_status, healthy ) splitted_names_tbru -strsplit(taxa_names(mtph_phy_pos_cured_no_treat), \\\\| ) splitted_names_tbru_length -lengths(splitted_names_tbru) taxa_names(mtph_phy_pos_cured_no_treat)[splitted_names_tbru_length==7] mtph_phy_pos_cured_no_treat.speclevel -prune_taxa(taxa_names(mtph_phy_pos_cured_no_treat)[splitted_names_tbru_length==7], mtph_phy_pos_cured_no_treat) taxa_names(mtph_phy_pos_cured_no_treat.speclevel) -do.call('rbind',strsplit(taxa_names(mtph_phy_pos_cured_no_treat.speclevel), \\\\| ))[,7] Principle corrdinate analysis pdf(paste(mtph_results_folder,'pca_plot_cured_NMDS.pdf',sep= ),height = 7, width = 10) mtph_GP.ord - ordinate(mtph_phy_pos_cured_no_treat, NMDS , bray ) mtph.p.pca - plot_ordination(mtph_phy_pos_cured_no_treat, mtph_GP.ord, type= samples , color= TB_status ) Palette_LTBI_cured - c( #377eb8 , #e7298a ) mtph.p.pca - mtph.p.pca + geom_point(size=4)+ theme_base()+ scale_color_manual(values=c(Palette_LTBI_cured)) print(mtph.p.pca) dev.off() assignCols - function(names,selection) { mymap -list() availableCols -c( #000000 , #FFFF00 , #1CE6FF , #FF34FF , #FF4A46 , #008941 , #006FA6 , #A30059 , #FFDBE5 , #7A4900 , #0000A6 , #63FFAC , #B79762 , #004D43 , #8FB0FF , #997D87 , #5A0007 , #809693 , #FEFFE6 , #1B4400 , #4FC601 , #3B5DFF , #4A3B53 , #FF2F80 , #61615A , #BA0900 , #6B7900 , #00C2A0 , #FFAA92 , #FF90C9 , #B903AA , #D16100 , #DDEFFF , #000035 , #7B4F4B , #A1C299 , #300018 , #0AA6D8 , #013349 , #00846F , #372101 , #FFB500 , #C2FFED , #A079BF , #CC0744 , #C0B9B2 , #C2FF99 , #001E09 , #00489C , #6F0062 , #0CBD66 , #EEC3FF , #456D75 , #B77B68 , #7A87A1 , #788D66 , #885578 , #FAD09F , #FF8A9A , #D157A0 , #BEC459 , #456648 , #0086ED , #886F4C , #34362D , #B4A8BD , #00A6AA , #452C2C , #636375 , #A3C8C9 , #FF913F , #938A81 , #575329 , #00FECF , #B05B6F , #8CD0FF , #3B9700 , #04F757 , #C8A1A1 , #1E6E00 , #7900D7 , #A77500 , #6367A9 , #A05837 , #6B002C , #772600 , #D790FF , #9B9700 , #549E79 , #FFF69F , #201625 , #72418F , #BC23FF , #99ADC0 , #3A2465 , #922329 , #5B4534 , #FDE8DC , #404E55 , #0089A3 , #CB7E98 , #A4E804 , #324E72 , #6A3A4C , #83AB58 , #001C1E , #D1F7CE , #004B28 , #C8D0F6 , #A3A489 , #806C66 , #222800 , #BF5650 , #E83000 , #66796D , #DA007C , #FF1A59 , #8ADBB4 , #1E0200 , #5B4E51 , #C895C5 , #320033 , #FF6832 , #66E1D3 , #CFCDAC , #D0AC94 , #7ED379 , #012C58 ) mymap[[1]] -rev(availableCols[match(intersect(names,selection),names)]) mymap[[2]] -intersect(names,selection) mymap }; most_abundant_number -40 topN = most_abundant_number most_abundant_taxa = sort(taxa_sums(mtph_phy_pos_cured_no_treat.speclevel), TRUE)[1:topN] GP = prune_taxa(names(most_abundant_taxa), mtph_phy_pos_cured_no_treat.speclevel) mGPr - psmelt(GP) mycol - assignCols(unique(mGPr$OTU),unique(mGPr$OTU)) pdf(paste(results_folder,'barplot_all.pdf',sep= ),height = 7, width = 10) p.bar -ggplot(data=mGPr,aes(Patient.ID, Abundance, fill=OTU))+ geom_bar(stat = identity ) + theme_base()+ theme(axis.text.x=element_text(angle=90,hjust=1,vjust=0.5)) + scale_fill_manual(values = mycol[[1]],breaks=mycol[[2]]) + facet_wrap(~TB_status,scales= free )+ xlab( ) print(p.bar) dev.off() Run LEfSe on Cured vs LTBI system( echo $PATH ) # # #aquire sample data from phy phy.lefse -mtph_phy_pos_cured_no_treat.speclevel class - TB_status subclass -FALSE subject - sample anova.alpha -0.05 wilcoxon.alpha -0.05 lda.cutoff -2.0 wilcoxon.within.subclass - TRUE one.against.one - FALSE mult.test.correction - 0 make.lefse.plots - FALSE by_otus - FALSE # sample.data - phyloseq::sample_data(phy.lefse) % % data.frame(stringsAsFactors = FALSE) sample.data$sample - rownames(sample.data) # keepvars - c( sample , TB_status ) keepvars - unique(keepvars[!is.na(keepvars)]) lefse.samp - sample.data[, keepvars] # sample0 - t(lefse.samp) % % as.matrix() colnames(sample0) - sample0[1,] sample0 - as.data.frame(sample0) # data0 - otu_table(phy.lefse) % % as.data.frame() data1 - data0 % % as.data.table(keep.rownames=T) sample1 - sample0 % % as.data.table(keep.rownames=T) common - intersect(colnames(data1), colnames(sample1)) pre.lefse - rbind(sample1, data1,fill=T) % % t() % % na.omit() % % t() # write.table(pre.lefse,file =paste(results_folder, lefse.txt ,sep= ),sep = \\t ,row.names = FALSE,col.names = FALSE,quote = FALSE) # opt.class - paste( -c , which(keepvars %in% class)) opt.subclass - ifelse(is.na(subclass), , paste( -s , which(keepvars %in% subclass))) opt.subject - ifelse(is.na(subject), , paste( -u , which(keepvars %in% subject))) format.command - paste(paste( ~/miniconda2/bin/python ~/lefse/format_input.py ,results_folder, lefse.txt ,results_folder, lefse.in ,sep= ), opt.class, opt.subject, -o 1000000 ) system(format.command) # lefse.command - paste(paste( run_lefse.py ,results_folder, lefse.in ,results_folder, lefse.res ,sep= ), -a , anova.alpha, -w , wilcoxon.alpha, -l , lda.cutoff, -e , as.numeric(wilcoxon.within.subclass), -y , as.numeric(one.against.one), -s , mult.test.correction) lefse.command system(lefse.command) lefse.out - read.table(paste(results_folder, lefse.res ,sep= ), header = FALSE, sep = \\t ) names(lefse.out) -c( taxon , log.max.pct , direction , lda , p.value ) (lefse.out -na.omit(lefse.out)) if (make.lefse.plots) { system( plot_res.py lefse.res lefse_lda.png ) print( Wrote lefse_lda.png ) system( plot_cladogram.py lefse.res lefse_clado.pdf --format pdf ) print( Wrote lefse_clado.pdf ) } # pdf(paste(results_folder,'lda_plot_LEFSE.pdf',sep= ),height = 4, width = 10) Palette_LTBI_cured - c( #e7298a , #377eb8 ) if(length(unique(lefse.out$direction)) 3){ lefse.out$lda[lefse.out$direction==unique(lefse.out$direction)[1]] - -1*lefse.out$lda[lefse.out$direction==unique(lefse.out$direction)[1]] } lefse.out$taxon -factor(lefse.out$taxon,levels=lefse.out$taxon[order(lefse.out$lda)]) g1 -ggplot(data=lefse.out,aes(x=taxon,y=lda,color=direction,fill=direction))+ geom_bar(stat= identity )+ coord_flip()+ theme_base()+ xlab( LDA Score )+ ylab( ) if(length(unique(lefse.out$direction)) 3){ g1 -g1+scale_color_manual(values=c(Palette_LTBI_cured))+ scale_fill_manual(values=c(Palette_LTBI_cured)) } print(g1) dev.off() ltk -as.character(lefse.out$taxon) phy_ra_ltk -prune_taxa(ltk,phy.lefse) phy_ra_ltk_m -psmelt(phy_ra_ltk) phy_ra_ltk_m$OTU -factor(phy_ra_ltk_m$OTU, levels=lefse.out$taxon[order(lefse.out$lda)]) Palette_LTBI_cured - c( #377eb8 , #e7298a ) g2 -ggplot(phy_ra_ltk_m,aes(x=OTU, y=Abundance,color=TB_status, fill=TB_status))+ geom_boxplot(position=position_dodge(), colour= black , # Use black outlines, size=.3,alpha=0.5) + # Thinner lines theme_base()+ xlab( )+ coord_flip() if(length(unique(lefse.out$direction)) 3){ g2 -g2+scale_color_manual(values=c(Palette_LTBI_cured))+ scale_fill_manual(values=c(Palette_LTBI_cured)) } pdf(paste(results_folder,'significant_LEFSE.pdf',sep= ),height = 6, width = 10) print(g2) dev.off()","title":"Cured"},{"location":"Cured_metagenomics/#loading-the-data","text":"rm (list = ls()) library( phyloseq );library( ggplot2 );library( gridExtra );library( RColorBrewer );library( colorspace ); library( lattice );library( plyr );library( pracma );library( ggthemes );library( pheatmap );library( ComplexHeatmap ); library( BiocParallel );library( genefilter );library( DESeq2 );library( tidyr );library( viridis );library(data.table); library( KEGGREST ) setwd( ~/Desktop/metagenomics/Jan04_17_results ) register(MulticoreParam(30)) asinTransform - function(p) { asin(sqrt(p)) } mainDir - ../metagenomics/ subDir - metaphlan_profiling_cured dir.create(file.path(mainDir, subDir), showWarnings = TRUE, recursive = TRUE) results_folder - paste(mainDir,subDir,sep= ) mtph_subDir - metaphlan_profiling/ dir.create(file.path(mainDir, mtph_subDir), showWarnings = TRUE, recursive = TRUE) mtph_results_folder - paste(mainDir,mtph_subDir,sep= ) mtph_dat - read.csv( ../tbru_ss_data/metaphlan2_taxonomic_table_joined.tsv ,sep= \\t ) mtph -mtph_dat rownames(mtph) -mtph$X.SampleID mtph$X.SampleID -NULL mtph_otudata -otu_table(mtph,taxa_are_rows = TRUE) mtph_taxmat - matrix(sample(letters, nrow(mtph_otudata)/10, replace = TRUE), nrow = nrow(mtph_otudata), ncol = 7) rownames(mtph_taxmat) - rownames(mtph_otudata) colnames(mtph_taxmat) - c( Domain , Phylum , Class , Order , Family , Genus , Species ) mtph_taxmat -tax_table(mtph_taxmat) mtph_phy - phyloseq(mtph_otudata, mtph_taxmat)","title":"Loading the data"},{"location":"Cured_metagenomics/#import-the-metaphlan-data-to-phyloseq","text":"metadata.file - ../tbru_ss_data/TBRU_Metadata_May2017.csv metadata - read.csv(metadata.file,na.strings=c( N/A , 99999 )) metadata[is.na(metadata)] - 99999 metadata$sample -gsub( - , . ,metadata$sample) samp - metadata % % data.frame() rownames(samp) -metadata$sample snames -as.data.frame(do.call('rbind',strsplit(sample_names(mtph_phy), _ )))[,1] sample_names(mtph_phy) -snames sample_data(mtph_phy) -samp # subsettings mtph_phy_pos_cured_no_treat -subset_samples(mtph_phy,!is.na(TB_status) TB_status!= treatment ) mtph_phy_pos_cured_no_treat - subset_samples(mtph_phy_pos_cured_no_treat,!is.na(Group6_TB_category) Group6_TB_category!= family_member ) # keep only 38 years old in age mtph_phy_pos_cured_no_treat - subset_samples(mtph_phy_pos_cured_no_treat,age =38) sample_data(mtph_phy_pos_cured_no_treat)$TB_status - relevel(sample_data(mtph_phy_pos_cured_no_treat)$TB_status, healthy ) splitted_names_tbru -strsplit(taxa_names(mtph_phy_pos_cured_no_treat), \\\\| ) splitted_names_tbru_length -lengths(splitted_names_tbru) taxa_names(mtph_phy_pos_cured_no_treat)[splitted_names_tbru_length==7] mtph_phy_pos_cured_no_treat.speclevel -prune_taxa(taxa_names(mtph_phy_pos_cured_no_treat)[splitted_names_tbru_length==7], mtph_phy_pos_cured_no_treat) taxa_names(mtph_phy_pos_cured_no_treat.speclevel) -do.call('rbind',strsplit(taxa_names(mtph_phy_pos_cured_no_treat.speclevel), \\\\| ))[,7]","title":"Import the metaphlan data to phyloseq"},{"location":"Cured_metagenomics/#principle-corrdinate-analysis","text":"pdf(paste(mtph_results_folder,'pca_plot_cured_NMDS.pdf',sep= ),height = 7, width = 10) mtph_GP.ord - ordinate(mtph_phy_pos_cured_no_treat, NMDS , bray ) mtph.p.pca - plot_ordination(mtph_phy_pos_cured_no_treat, mtph_GP.ord, type= samples , color= TB_status ) Palette_LTBI_cured - c( #377eb8 , #e7298a ) mtph.p.pca - mtph.p.pca + geom_point(size=4)+ theme_base()+ scale_color_manual(values=c(Palette_LTBI_cured)) print(mtph.p.pca) dev.off() assignCols - function(names,selection) { mymap -list() availableCols -c( #000000 , #FFFF00 , #1CE6FF , #FF34FF , #FF4A46 , #008941 , #006FA6 , #A30059 , #FFDBE5 , #7A4900 , #0000A6 , #63FFAC , #B79762 , #004D43 , #8FB0FF , #997D87 , #5A0007 , #809693 , #FEFFE6 , #1B4400 , #4FC601 , #3B5DFF , #4A3B53 , #FF2F80 , #61615A , #BA0900 , #6B7900 , #00C2A0 , #FFAA92 , #FF90C9 , #B903AA , #D16100 , #DDEFFF , #000035 , #7B4F4B , #A1C299 , #300018 , #0AA6D8 , #013349 , #00846F , #372101 , #FFB500 , #C2FFED , #A079BF , #CC0744 , #C0B9B2 , #C2FF99 , #001E09 , #00489C , #6F0062 , #0CBD66 , #EEC3FF , #456D75 , #B77B68 , #7A87A1 , #788D66 , #885578 , #FAD09F , #FF8A9A , #D157A0 , #BEC459 , #456648 , #0086ED , #886F4C , #34362D , #B4A8BD , #00A6AA , #452C2C , #636375 , #A3C8C9 , #FF913F , #938A81 , #575329 , #00FECF , #B05B6F , #8CD0FF , #3B9700 , #04F757 , #C8A1A1 , #1E6E00 , #7900D7 , #A77500 , #6367A9 , #A05837 , #6B002C , #772600 , #D790FF , #9B9700 , #549E79 , #FFF69F , #201625 , #72418F , #BC23FF , #99ADC0 , #3A2465 , #922329 , #5B4534 , #FDE8DC , #404E55 , #0089A3 , #CB7E98 , #A4E804 , #324E72 , #6A3A4C , #83AB58 , #001C1E , #D1F7CE , #004B28 , #C8D0F6 , #A3A489 , #806C66 , #222800 , #BF5650 , #E83000 , #66796D , #DA007C , #FF1A59 , #8ADBB4 , #1E0200 , #5B4E51 , #C895C5 , #320033 , #FF6832 , #66E1D3 , #CFCDAC , #D0AC94 , #7ED379 , #012C58 ) mymap[[1]] -rev(availableCols[match(intersect(names,selection),names)]) mymap[[2]] -intersect(names,selection) mymap }; most_abundant_number -40 topN = most_abundant_number most_abundant_taxa = sort(taxa_sums(mtph_phy_pos_cured_no_treat.speclevel), TRUE)[1:topN] GP = prune_taxa(names(most_abundant_taxa), mtph_phy_pos_cured_no_treat.speclevel) mGPr - psmelt(GP) mycol - assignCols(unique(mGPr$OTU),unique(mGPr$OTU)) pdf(paste(results_folder,'barplot_all.pdf',sep= ),height = 7, width = 10) p.bar -ggplot(data=mGPr,aes(Patient.ID, Abundance, fill=OTU))+ geom_bar(stat = identity ) + theme_base()+ theme(axis.text.x=element_text(angle=90,hjust=1,vjust=0.5)) + scale_fill_manual(values = mycol[[1]],breaks=mycol[[2]]) + facet_wrap(~TB_status,scales= free )+ xlab( ) print(p.bar) dev.off()","title":"Principle corrdinate analysis"},{"location":"Cured_metagenomics/#run-lefse-on-cured-vs-ltbi","text":"system( echo $PATH ) # # #aquire sample data from phy phy.lefse -mtph_phy_pos_cured_no_treat.speclevel class - TB_status subclass -FALSE subject - sample anova.alpha -0.05 wilcoxon.alpha -0.05 lda.cutoff -2.0 wilcoxon.within.subclass - TRUE one.against.one - FALSE mult.test.correction - 0 make.lefse.plots - FALSE by_otus - FALSE # sample.data - phyloseq::sample_data(phy.lefse) % % data.frame(stringsAsFactors = FALSE) sample.data$sample - rownames(sample.data) # keepvars - c( sample , TB_status ) keepvars - unique(keepvars[!is.na(keepvars)]) lefse.samp - sample.data[, keepvars] # sample0 - t(lefse.samp) % % as.matrix() colnames(sample0) - sample0[1,] sample0 - as.data.frame(sample0) # data0 - otu_table(phy.lefse) % % as.data.frame() data1 - data0 % % as.data.table(keep.rownames=T) sample1 - sample0 % % as.data.table(keep.rownames=T) common - intersect(colnames(data1), colnames(sample1)) pre.lefse - rbind(sample1, data1,fill=T) % % t() % % na.omit() % % t() # write.table(pre.lefse,file =paste(results_folder, lefse.txt ,sep= ),sep = \\t ,row.names = FALSE,col.names = FALSE,quote = FALSE) # opt.class - paste( -c , which(keepvars %in% class)) opt.subclass - ifelse(is.na(subclass), , paste( -s , which(keepvars %in% subclass))) opt.subject - ifelse(is.na(subject), , paste( -u , which(keepvars %in% subject))) format.command - paste(paste( ~/miniconda2/bin/python ~/lefse/format_input.py ,results_folder, lefse.txt ,results_folder, lefse.in ,sep= ), opt.class, opt.subject, -o 1000000 ) system(format.command) # lefse.command - paste(paste( run_lefse.py ,results_folder, lefse.in ,results_folder, lefse.res ,sep= ), -a , anova.alpha, -w , wilcoxon.alpha, -l , lda.cutoff, -e , as.numeric(wilcoxon.within.subclass), -y , as.numeric(one.against.one), -s , mult.test.correction) lefse.command system(lefse.command) lefse.out - read.table(paste(results_folder, lefse.res ,sep= ), header = FALSE, sep = \\t ) names(lefse.out) -c( taxon , log.max.pct , direction , lda , p.value ) (lefse.out -na.omit(lefse.out)) if (make.lefse.plots) { system( plot_res.py lefse.res lefse_lda.png ) print( Wrote lefse_lda.png ) system( plot_cladogram.py lefse.res lefse_clado.pdf --format pdf ) print( Wrote lefse_clado.pdf ) } # pdf(paste(results_folder,'lda_plot_LEFSE.pdf',sep= ),height = 4, width = 10) Palette_LTBI_cured - c( #e7298a , #377eb8 ) if(length(unique(lefse.out$direction)) 3){ lefse.out$lda[lefse.out$direction==unique(lefse.out$direction)[1]] - -1*lefse.out$lda[lefse.out$direction==unique(lefse.out$direction)[1]] } lefse.out$taxon -factor(lefse.out$taxon,levels=lefse.out$taxon[order(lefse.out$lda)]) g1 -ggplot(data=lefse.out,aes(x=taxon,y=lda,color=direction,fill=direction))+ geom_bar(stat= identity )+ coord_flip()+ theme_base()+ xlab( LDA Score )+ ylab( ) if(length(unique(lefse.out$direction)) 3){ g1 -g1+scale_color_manual(values=c(Palette_LTBI_cured))+ scale_fill_manual(values=c(Palette_LTBI_cured)) } print(g1) dev.off() ltk -as.character(lefse.out$taxon) phy_ra_ltk -prune_taxa(ltk,phy.lefse) phy_ra_ltk_m -psmelt(phy_ra_ltk) phy_ra_ltk_m$OTU -factor(phy_ra_ltk_m$OTU, levels=lefse.out$taxon[order(lefse.out$lda)]) Palette_LTBI_cured - c( #377eb8 , #e7298a ) g2 -ggplot(phy_ra_ltk_m,aes(x=OTU, y=Abundance,color=TB_status, fill=TB_status))+ geom_boxplot(position=position_dodge(), colour= black , # Use black outlines, size=.3,alpha=0.5) + # Thinner lines theme_base()+ xlab( )+ coord_flip() if(length(unique(lefse.out$direction)) 3){ g2 -g2+scale_color_manual(values=c(Palette_LTBI_cured))+ scale_fill_manual(values=c(Palette_LTBI_cured)) } pdf(paste(results_folder,'significant_LEFSE.pdf',sep= ),height = 6, width = 10) print(g2) dev.off()","title":"Run LEfSe on Cured vs LTBI"},{"location":"GettingStarted/","text":"TBRU microbiome data analysis page Getting started Microbiome data analysis seems daunting, but it is not. There are a few core set of skills that one must learn, but just like a mere 26 letters in the alphabet and a few general rules can be used to produce a masterpiece like James Joyce's Ulysses, the same is true for all next generation sequencing data analysis. The pipelines are straightforward, and once the learning curve has plateaued, they are a lot of fun! The same set of concepts can be applied to any sort of next generation data generation technique, ranging from 16S amplicon DNA sequencing, metagenomic DNA sequencing, RNAseq, metabolomics, and more! Qiime Download Qiime here RStudio You can download RStudio here Uparse pipeline You can read about and download steps to process 16S amplicon data on the drive5.com webpage . There are other methods to generate OTUs, but this is the method we use. All about Phyloseq! Phyloseq is a Bioconductor package that integrates all of the necessary types of data to describe a microbiome. Specifically, the sequence data, sample metadata, taxonomy information of each sequence, and a phylogenetic tree of the sequences are all easily integrated into one \"phyloseq object\". Extracting data from this object in R is simple, and it makes downstream analyses simple and reproducible. Conda and Anaconda Conda is a package management system that helps you find and install new packages. Read more about it here . Conda is very easy to install . It is also easy to install Anaconda--see here . The miniconda version of python2.7 (miniconda2/bin/python) is required for LEfSe and some other microbiome tools. Installing conda and anaconda will likely modify your $PATH to make this the default, but if not, then be aware that when running any python scripts (e.g., run_lefse.py), you'll need to point to the directory containing the miniconda version of python2.7. You can find out the default python on your system by opening a terminal window and typing \"which python\".","title":"Getting Started"},{"location":"GettingStarted/#tbru-microbiome-data-analysis-page","text":"","title":"TBRU microbiome data analysis page"},{"location":"GettingStarted/#getting-started","text":"Microbiome data analysis seems daunting, but it is not. There are a few core set of skills that one must learn, but just like a mere 26 letters in the alphabet and a few general rules can be used to produce a masterpiece like James Joyce's Ulysses, the same is true for all next generation sequencing data analysis. The pipelines are straightforward, and once the learning curve has plateaued, they are a lot of fun! The same set of concepts can be applied to any sort of next generation data generation technique, ranging from 16S amplicon DNA sequencing, metagenomic DNA sequencing, RNAseq, metabolomics, and more!","title":"Getting started"},{"location":"GettingStarted/#qiime","text":"Download Qiime here","title":"Qiime"},{"location":"GettingStarted/#rstudio","text":"You can download RStudio here","title":"RStudio"},{"location":"GettingStarted/#uparse-pipeline","text":"You can read about and download steps to process 16S amplicon data on the drive5.com webpage . There are other methods to generate OTUs, but this is the method we use.","title":"Uparse pipeline"},{"location":"GettingStarted/#all-about-phyloseq","text":"Phyloseq is a Bioconductor package that integrates all of the necessary types of data to describe a microbiome. Specifically, the sequence data, sample metadata, taxonomy information of each sequence, and a phylogenetic tree of the sequences are all easily integrated into one \"phyloseq object\". Extracting data from this object in R is simple, and it makes downstream analyses simple and reproducible.","title":"All about Phyloseq!"},{"location":"GettingStarted/#conda-and-anaconda","text":"Conda is a package management system that helps you find and install new packages. Read more about it here . Conda is very easy to install . It is also easy to install Anaconda--see here . The miniconda version of python2.7 (miniconda2/bin/python) is required for LEfSe and some other microbiome tools. Installing conda and anaconda will likely modify your $PATH to make this the default, but if not, then be aware that when running any python scripts (e.g., run_lefse.py), you'll need to point to the directory containing the miniconda version of python2.7. You can find out the default python on your system by opening a terminal window and typing \"which python\".","title":"Conda and Anaconda"},{"location":"IGRA/","text":"IGRA status and microbiome composition Adonis test There are seemingly innumerable ways to query for differences in microbial community composition. Given the zero-inflated type of microbiome data, non-parametric analyses are most appropriate to ask if a statistical difference exists between two groups. In the case of IGRA status, we concluded that LTBI (being IGRA+) has no detectable effect on intestinal microbiome composition. What we formally did was a non-parametric multivariate ANOVA on the microbiome features between IGRA- and IGRA+ people. The following analysis compares 46 IGRA- and 55 IGRA+ people (data in the phy_NoTB_LTBI Phyloseq object). # Calculate bray curtis distance matrix bray - phyloseq::distance(phy_NoTB_LTBI, method = bray ) # make a data frame from the sample_data sampledf - data.frame(sample_data(phy_NoTB_LTBI)) # Adonis test library(vegan) adonis(bray ~ IGRA + age + sex, data = sampledf) Df SumsOfSqs MeanSqs F.Model R2 Pr( F) IGRA 1 0.353 0.35288 1.0630 0.01054 0.319 age 1 0.532 0.53233 1.6036 0.01590 0.044 * sex 1 0.386 0.38622 1.1635 0.01154 0.225 Residuals 97 32.201 0.33196 - 0.96201 Total 100 33.472 - - 1.00000 Signif. codes: 0 \u2018 \u2019 0.001 \u2018 \u2019 0.01 \u2018 \u2019 0.05 \u2018.\u2019 0.1 \u2018 \u2019 1 We can see that if anything, age is the major factor that contributes to variation between IGRA- and IGRA+ individuals. In fact, age has been described as a major contributer to microbiome variation (for a variety of reasons), thus, we made sure to control for age in our study. beta - betadisper(treat_bray, sampledf$IGRA) permutest(beta) Df Sum Sq Mean Sq F N.Perm Pr( F) Groups 1 0.02456 0.0245641 3.8261 999 0.05 * Residuals 99 0.63560 0.0064202","title":"IGRA status"},{"location":"IGRA/#igra-status-and-microbiome-composition","text":"","title":"IGRA status and microbiome composition"},{"location":"IGRA/#adonis-test","text":"There are seemingly innumerable ways to query for differences in microbial community composition. Given the zero-inflated type of microbiome data, non-parametric analyses are most appropriate to ask if a statistical difference exists between two groups. In the case of IGRA status, we concluded that LTBI (being IGRA+) has no detectable effect on intestinal microbiome composition. What we formally did was a non-parametric multivariate ANOVA on the microbiome features between IGRA- and IGRA+ people. The following analysis compares 46 IGRA- and 55 IGRA+ people (data in the phy_NoTB_LTBI Phyloseq object). # Calculate bray curtis distance matrix bray - phyloseq::distance(phy_NoTB_LTBI, method = bray ) # make a data frame from the sample_data sampledf - data.frame(sample_data(phy_NoTB_LTBI)) # Adonis test library(vegan) adonis(bray ~ IGRA + age + sex, data = sampledf) Df SumsOfSqs MeanSqs F.Model R2 Pr( F) IGRA 1 0.353 0.35288 1.0630 0.01054 0.319 age 1 0.532 0.53233 1.6036 0.01590 0.044 * sex 1 0.386 0.38622 1.1635 0.01154 0.225 Residuals 97 32.201 0.33196 - 0.96201 Total 100 33.472 - - 1.00000 Signif. codes: 0 \u2018 \u2019 0.001 \u2018 \u2019 0.01 \u2018 \u2019 0.05 \u2018.\u2019 0.1 \u2018 \u2019 1 We can see that if anything, age is the major factor that contributes to variation between IGRA- and IGRA+ individuals. In fact, age has been described as a major contributer to microbiome variation (for a variety of reasons), thus, we made sure to control for age in our study. beta - betadisper(treat_bray, sampledf$IGRA) permutest(beta) Df Sum Sq Mean Sq F N.Perm Pr( F) Groups 1 0.02456 0.0245641 3.8261 999 0.05 * Residuals 99 0.63560 0.0064202","title":"Adonis test"},{"location":"MAIT_GD_Tcells/","text":"Code to reproduce Figure 5 from doi: 10.1172/jci.insight.121899 setwd( ~/Desktop/Charles_MAIT/ ) #pick a directory rm(list=ls()) library(plyr);library(ggtree);library(phyloseq);library(ggplot2);library(scales);library(grid) library(Hmisc);library(gridExtra);library(scales);library(stringr);library(logistf) library(coxphf);library(reshape2);library(ifultools);library(car);library(vegan) library(gdata);library(chron);library(data.table);library(tidyr) #imports tibble library(ggplot2);library(yingtools2);library(gridExtra);library(lubridate);library(dplyr) library( pheatmap );library( RColorBrewer );library( genefilter );library(ggthemes) library( reshape2 );library( gridExtra );library( colorspace );library( lattice ) library( pracma );library( ComplexHeatmap );library( BiocParallel );library( viridis );library( circlize ) select - dplyr::select summarize - dplyr::summarize rownames_to_column - tibble::rownames_to_column phy_contacts - readRDS( phy.JCI.RDS ) Clinical variables that explain microbiome differences # Calculate bray curtis distance matrix bray - phyloseq::distance(phy_contacts, method = bray ) # make a data frame from the sample_data sampledf - data.frame(sample_data(phy_contacts)) # Adonis test library(vegan) set.seed(12345678) adonis2(bray ~ IGRA + sex + Group6_TB_category, data = sampledf) Permutation test for adonis under reduced model Terms added sequentially (first to last) Permutation: free Number of permutations: 999 Df SumsOfSqs MeanSqs F.Model R2 Pr( F) IGRA 1 0.03927 0.01281 0.6705 0.851 sex 2 0.17300 0.05644 1.4769 0.072 . Group6_TB_category 1 0.21748 0.07095 3.7132 0.001 *** Residual 45 2.63568 0.85981 Total 49 3.06544 1.00000 --- This indicates that the variable 'Group6_TB_category' explains the variation between individuals given their microbiome compositioin (***), but IGRA status and sex do not contribute to this variation. beta - betadisper(bray, sampledf$Group6_TB_category) permutest(beta) Permutation test for homogeneity of multivariate dispersions Permutation: free Number of permutations: 999 Df Sum Sq Mean Sq F N.Perm Pr( F) Groups 1 0.00044 0.00044028 0.1967 999 0.663 Residuals 48 0.10747 0.00223889 ```{r} #docker run -v ~/Desktop/Charles_MAIT/:/home/linuxbrew/inputs -it biobakery/lefse bash N.B. Running LEfSe locally can be difficult if your system(\"echo $PATH\") within R doesn't contain the LEfSe scripts, or if you constantly update R packages (like I do). This is guarenteed to cause problems with running LEfSe (e.g., rpy2 doesn't seem to be supported on my Mac any longer), so I've found docker to be an easy option. I run the above command on the command line, and can then run subsequent commands from R. system( echo $PATH ) results_folder - ~/Desktop/Charles_MAIT/ #make names lefse-friendly for python scripts taxa_names(phy_contacts) -gsub('\\\\(','',taxa_names(phy_contacts)) taxa_names(phy_contacts) -gsub(')','',taxa_names(phy_contacts)) taxa_names(phy_contacts) -gsub(' ','_',taxa_names(phy_contacts)) taxa_names(phy_contacts) phy.lefse -phy_contacts class - Group6_TB_category subclass -NA subject - sample anova.alpha -0.01 wilcoxon.alpha -0.01 lda.cutoff -2.5 wilcoxon.within.subclass - TRUE one.against.one - FALSE mult.test.correction - 0 make.lefse.plots - FALSE by_otus - FALSE # sample.data - phyloseq::sample_data(phy.lefse) % % data.frame(stringsAsFactors = FALSE) sample.data - rownames_to_column(sample.data,var= sample ) # keepvars - c( sample , Group6_TB_category ) keepvars - unique(keepvars[!is.na(keepvars)]) lefse.samp - sample.data[, keepvars] # sample0 - t(lefse.samp) % % as.matrix() colnames(sample0) - sample0[1,] sample0 - as.data.frame(sample0) % % t() % % as.data.frame() data0 - otu_table(phy.lefse) % % as.data.frame() data1 - data0 % % as.data.table(keep.rownames=T) % % t() data2 - rownames_to_column(as.data.frame(data1),var= sample ) pre.lefse - right_join(sample0,data2,by= sample ) % % t() rownames(pre.lefse) - NULL pre.lefse[1,1] - sample pre.lefse[2,1] - IGRA pre.lefse - pre.lefse % % t() % % na.omit() % % t() # write.table(pre.lefse,file =paste(results_folder, lefse.txt ,sep= ),sep = \\t ,row.names = FALSE,col.names = FALSE,quote = FALSE) # opt.class - paste( -c , which(keepvars %in% class)) opt.subclass - ifelse(is.na(subclass), , paste( -s , which(keepvars %in% subclass))) opt.subject - ifelse(is.na(subject), , paste( -u , which(keepvars %in% subject))) format.command - paste(paste( format_input.py ,results_folder, lefse.txt ,results_folder, lefse.in ,sep= ), opt.class, opt.subclass, opt.subject, -o 1000000 ) system(format.command) # #docker run -v ~/Desktop/Charles_MAIT/:/home/linuxbrew/inputs -it biobakery/lefse bash lefse.command - paste(paste( run_lefse.py , lefse.in , lefse.res ,sep= ), -a , anova.alpha, -w , wilcoxon.alpha, -l , lda.cutoff, -e , as.numeric(wilcoxon.within.subclass), -y , as.numeric(one.against.one), -s , mult.test.correction) lefse.command system(lefse.command) lefse.out - read.table(paste( lefse.res ,sep= ), header = FALSE, sep = \\t ) names(lefse.out) -c( taxon , log.max.pct , direction , lda , p.value ) (lefse.out -na.omit(lefse.out)) Palette_LTBI_treatment - c( #377eb8 , #984ea3 ) #modify this ltk -as.character(lefse.out$taxon) phy_ra_ltk -prune_taxa(ltk,phy_contacts) phy_ra_ltk_m -psmelt(phy_ra_ltk) Palette_FC_CC - c( #00C000 , #7F007F ) g2 -ggplot(phy_ra_ltk_m,aes(x=OTU, y=Abundance,color=Group6_TB_category, fill=Group6_TB_category))+ geom_boxplot(position=position_dodge(), colour= black , # Use black outlines, size=.3,alpha=0.5) + # Thinner lines theme_base()+ xlab( )+ coord_flip()+ facet_wrap(~Group6_TB_category) + scale_y_continuous(limits = c(0,15)) if(length(unique(lefse.out$direction)) 3){ g2 -g2+scale_color_manual(values=c(Palette_FC_CC))+ scale_fill_manual(values=c(Palette_FC_CC)) } print(g2) ![abundance_plot](img/MAIT_GD/Correlated_FC-CC_0.01_LDA2.5_all.png) This for loop correlated specifc immune phenotypes (vars_to_keep) with microbiota abundance. It generates a lot of intermediate plots of the individual correlations, but I won't show those. #big for loop mainDir - ~/Desktop/Charles_MAIT/ subDir - DESeq_FC-CC_immune dir.create(file.path(mainDir, subDir), showWarnings = TRUE,recursive = TRUE) results_folder - paste(mainDir,subDir,sep= ) cor_ht_dt - NULL heat_dt - data.frame(taxon = NULL, rho = NULL, effectors = NULL) sample_variables(phy) vars_to_keep - c( il17m_5aru , il17m_dyna , cd4mil17_rest , cd8mil17_rest , dnmil17_rest , cd4mil17_5aru , cd8mil17_5aru , dnmil17_5aru , cd4mil17_dyna , cd8mil17_dyna , dnmil17_dyna , cd4til17_rest , cd8til17_rest , dntil17_rest , cd4til17_dyna , cd8til17_dyna , dntil17_dyna ) effectors_all - c(vars_to_keep) for (effectors in effectors_all){ # Subset the samples phy_var - subset_samples(phy_contacts,!is.na(get_variable(phy_contacts, effectors)) | get_variable(phy_contacts, effectors)!= ) phy_var - subset_samples(phy_var, get_variable(phy_var, effectors) != na ) phy_var - subset_samples(phy_var, get_variable(phy_var, effectors) != ) sdat -otu_table(phy_var) % % as.data.frame() xcor -get_variable(phy_var, effectors) c_th -0.05 c_pvalue -list() c_estimate -list() for (ic in seq(1,nrow(sdat))){ ycor -sdat[ic,] cor.result -cor.test(as.numeric(xcor),as.numeric(ycor),method = spearman ) #nonparametric = spearman c_pvalue[[ic]] - cor.result$p.value c_estimate[[ic]] - cor.result$estimate } c_pvalue -do.call('rbind',c_pvalue) c_estimate -do.call('rbind',c_estimate) isig -which(c_pvalue = c_th) taxa_sig -taxa_names(phy_var)[isig] c_pvalue_sig -c_pvalue[isig] c_estimate_sig -c_estimate[isig] correlation_results -data.frame(taxa_sig,c_pvalue_sig,c_estimate_sig) names(correlation_results) -c( taxon , pvalue , spearman_rho ) if(nrow(correlation_results) 0){ correlation_results$rho -as.numeric(correlation_results$spearman_rho) correlation_results$taxon -factor(correlation_results$taxon, levels=correlation_results$taxon[order(correlation_results$spearman_rho)]) correlation_results$i_eff - effectors # Cut off for rho 0.4 = spearman_rho spearman_rho = -0.4 correlation_results - correlation_results[which(abs(correlation_results$spearman_rho) = 0.2) ,] if(nrow(correlation_results) 0){ cor_ht_dt - rbind(cor_ht_dt, correlation_results) # barplot pdf(paste(results_folder,paste0( bar_plot_spearman_coeff ,effectors, .pdf ),sep= / ),height = 6, width = 10) g1 -ggplot(data=correlation_results,aes(x=taxon, y=rho))+ geom_bar(stat= identity )+ coord_flip()+ theme_base()+ xlab( Species )+ ylab( Spearman - rho ) print(g1) dev.off() # code below is for heatmap phy_sig_var - prune_taxa(as.character(correlation_results$taxon), phy_var) sig_data_c -data.frame(otu_table(phy_sig_var)) y_eff - as.numeric(as.character(get_variable(phy_sig_var, effectors))) pnca_colors -colorRamp2(c(min(log(y_eff+1)), max(log(y_eff+1))), c( white , blue )) dist_to_use -function(x) (1-dist(t(x))) mat -as.matrix(as.data.frame(sig_data_c)) mat2 -scale(t(mat), scale = T, center = T) mat2 -t(mat2) annotations -data.frame(y_eff,as.character(get_variable(phy_var, Group6_TB_category ))) names(annotations) -c( effectors , group )#, conventional_cd8mtreg )#, IGRA )#, group )# cd8mtreg ) # TB_status , IGRA , tmp_c - sample_data(phy_var) % % as.data.frame() #tmp_c[order(tmp_c)$effectors,] #[order(sample_data(phy_var)$effectors),] max_value - max(as.numeric(as.character(get_variable(phy_var, effectors)))) #color_col = list(effectors = colorRamp2(c(0,max_value),c( white , #DC143C )), #group = c( family_contact = #7F007F , community_control = #00C000 )) #color_col = list(effectors = colorRamp2(c(0,noquote(max(tmp_c$effectors))),c( white , #DC143C )), group = c( family_contact = #7F007F , community_control = #00C000 )) #ha_column = HeatmapAnnotation(annotations, col = color_col) ha_column = HeatmapAnnotation(annotations) ht1 = Heatmap(mat2, name = Relative Abundance , column_title = NA, top_annotation = ha_column, clustering_distance_rows = euclidean , clustering_method_rows = complete ,row_names_side = left , km=1, color_space = LAB , col=viridis(11), row_dend_side= right , clustering_method_columns = ward.D , width=4, row_names_max_width = unit(8, cm ),show_column_names= F, row_names_gp = gpar(fontsize = 9), cluster_columns = T,na_col= white ) ht_list = ht1 padding = unit.c(unit(2, mm ), grobWidth(textGrob( jnbksdffsdfsfd_annotation_name )) - unit(1, cm ), unit(c(2, 2), mm )) pdf(paste(results_folder,paste0( heatmap_spearman_0.01_ ,effectors, .pdf ),sep= / ),height = 2.5, width = 11) draw(ht_list, padding = padding) dev.off() } } } # Reshape the dataframe for heatmap cor_ht_dt - cor_ht_dt[,c( taxon , rho , i_eff )] # Convert long to wide format for phyloseq object cor_ht_dt_w - dcast(cor_ht_dt, taxon ~ i_eff, value.var= rho ,fun.aggregate = mean) cor_ht_dt_w[is.na(cor_ht_dt_w)] - 0 ######match tree with heatmap rownames phy_sig -prune_taxa(as.character(cor_ht_dt_w$taxon),phy_contacts) row_den - ape:::as.phylo(phy_tree(phy_sig)) # row_den - as.dendrogram(hclust(dist(cor_data))) # plot(row_den) #r_order - rev(row_den$tip.label) cor_data - cor_ht_dt_w rownames(cor_data) - cor_data$taxon cor_data$taxon - NULL clust.col - hclust(dist(t(cor_data))) plot(clust.col) col_den - as.dendrogram(clust.col) sig_data_c - cor_data mat -as.matrix(sig_data_c) mat2 -scale(t(mat), scale = F, center = F) mat2 -t(mat2) #rownames(mat2) - cor_ht_dt_w$taxon # #get data from ggTree # d - fortify(tr) # dd - subset(d, isTip) # r_order - dd$label[order(dd$y, decreasing=T)] # # mat3 - mat2[match(r_order,rownames(mat2)),] # Without phylogenetic tree clustering sig_data_c - cor_ht_dt_w[,2:ncol(cor_ht_dt_w)] dist_to_use -function(x) (1-dist(t(x))) mat -as.matrix(as.data.frame(sig_data_c)) mat2 -scale(t(mat), scale = F, center = F) mat2 -t(mat2) rownames(mat2) - cor_ht_dt_w$taxon rownames(mat2) - gsub( \\\\s*\\\\w*$ , , rownames(mat2)) jet.colors - colorRampPalette(c( #00007F , blue , #007FFF , cyan , #7FFF7F , yellow , #FF7F00 , red , #7F0000 )) jet.colors - colorRampPalette(c( red , grey , darkblue )) subsets - levels(as.factor(cor_ht_dt$i_eff)) #annotation - data.frame(subsets,c( CD4 , CD4 , CD8 , CD8 , DN , DN , CD4 ),row.names = T) #names(annotation) - c( subset ) #ha_column = HeatmapAnnotation(annotation) pdf(paste(results_folder, /heatmap_spearman_all_effectors_no_tree ,'.pdf',sep= ),height = 20, width = 10) ht1 = Heatmap(mat2, name = relativeAbundance , column_title = NA, #top_annotation = ha_column, #clustering_distance_rows = euclidean ,clustering_method_rows = complete , row_names_side = left , km=1, color_space = LAB , col=jet.colors(11), row_dend_side= right , clustering_method_columns = ward.D ,cluster_rows = F, width=4, row_names_max_width = unit(8, cm ),show_column_names= T, row_names_gp = gpar(fontsize = 9), cluster_columns = T,na_col= white ) ht_list = ht1 draw(ht_list) dev.off() Below is the key output: cor_ht_dt_w$taxon are the taxa that correlate with immune phenotypes, and lefse.out$taxon are the taxa that are differentially abundant between Family Contacts and Community Controls. We intersect these and only look at taxa that are significant for both. common -intersect(lefse.out$taxon,cor_ht_dt_w$taxon) phy_common - prune_taxa(taxa = common,phy_contacts) #Phylogenetic Tree phy_sig -prune_taxa(as.character(cor_ht_dt_w$taxon),phy_contacts) p.species - phy_common library(yingtools2) library(ggtree) tr - phy_tree(p.species) spec - as.data.frame(get.tax(p.species)) gt - ggtree(tr, branch.length = y ,ladderize = T) % +% spec gd - gt$data data_eff - cor_ht_dt_w rownames(data_eff) - cor_ht_dt_w$taxon data_eff$taxon - NULL data_eff - as.matrix(data_eff) #data_eff % % View g1 - gt + geom_tippoint(aes(color=Order),size=3) + geom_tiplab(size =3) # data_eff_cd4 - data_eff[,1:8] # data_eff_cd8 - data_eff[,9:15] g - gheatmap(g1,data_eff,offset=2.5, width=2,colnames_angle=-45,hjust=0,font.size = 5) + scale_fill_gradient2(low = darkred , mid = grey ,high = darkblue ) And finally, tsne plots were made with the tsnemicrobiota R package: #tsne plots library(phyloseq) library(tsnemicrobiota) library(ggplot2) tsne_res - tsne_phyloseq(phy_contacts, distance='jsd', perplexity = 8, verbose=0, rng_seed = 3901,dimensions=3) # Plot the results. #sample_data(phy_contacts)$cd4m_5aru - as.numeric(as.character(sample_data(phy_contacts)$cd4m_5aru)) plot_tsne_phyloseq(phy_contacts, tsne_res, color = 'Group6_TB_category',shape= IGRA , title='t-SNE (jsd)') + geom_point(size=3) + scale_color_manual(values=c(Palette_FC_CC))+ scale_fill_manual(values=c(Palette_FC_CC))","title":"Figure 5"},{"location":"MAIT_GD_Tcells/#clinical-variables-that-explain-microbiome-differences","text":"# Calculate bray curtis distance matrix bray - phyloseq::distance(phy_contacts, method = bray ) # make a data frame from the sample_data sampledf - data.frame(sample_data(phy_contacts)) # Adonis test library(vegan) set.seed(12345678) adonis2(bray ~ IGRA + sex + Group6_TB_category, data = sampledf) Permutation test for adonis under reduced model Terms added sequentially (first to last) Permutation: free Number of permutations: 999 Df SumsOfSqs MeanSqs F.Model R2 Pr( F) IGRA 1 0.03927 0.01281 0.6705 0.851 sex 2 0.17300 0.05644 1.4769 0.072 . Group6_TB_category 1 0.21748 0.07095 3.7132 0.001 *** Residual 45 2.63568 0.85981 Total 49 3.06544 1.00000 --- This indicates that the variable 'Group6_TB_category' explains the variation between individuals given their microbiome compositioin (***), but IGRA status and sex do not contribute to this variation. beta - betadisper(bray, sampledf$Group6_TB_category) permutest(beta) Permutation test for homogeneity of multivariate dispersions Permutation: free Number of permutations: 999 Df Sum Sq Mean Sq F N.Perm Pr( F) Groups 1 0.00044 0.00044028 0.1967 999 0.663 Residuals 48 0.10747 0.00223889 ```{r} #docker run -v ~/Desktop/Charles_MAIT/:/home/linuxbrew/inputs -it biobakery/lefse bash N.B. Running LEfSe locally can be difficult if your system(\"echo $PATH\") within R doesn't contain the LEfSe scripts, or if you constantly update R packages (like I do). This is guarenteed to cause problems with running LEfSe (e.g., rpy2 doesn't seem to be supported on my Mac any longer), so I've found docker to be an easy option. I run the above command on the command line, and can then run subsequent commands from R. system( echo $PATH ) results_folder - ~/Desktop/Charles_MAIT/ #make names lefse-friendly for python scripts taxa_names(phy_contacts) -gsub('\\\\(','',taxa_names(phy_contacts)) taxa_names(phy_contacts) -gsub(')','',taxa_names(phy_contacts)) taxa_names(phy_contacts) -gsub(' ','_',taxa_names(phy_contacts)) taxa_names(phy_contacts) phy.lefse -phy_contacts class - Group6_TB_category subclass -NA subject - sample anova.alpha -0.01 wilcoxon.alpha -0.01 lda.cutoff -2.5 wilcoxon.within.subclass - TRUE one.against.one - FALSE mult.test.correction - 0 make.lefse.plots - FALSE by_otus - FALSE # sample.data - phyloseq::sample_data(phy.lefse) % % data.frame(stringsAsFactors = FALSE) sample.data - rownames_to_column(sample.data,var= sample ) # keepvars - c( sample , Group6_TB_category ) keepvars - unique(keepvars[!is.na(keepvars)]) lefse.samp - sample.data[, keepvars] # sample0 - t(lefse.samp) % % as.matrix() colnames(sample0) - sample0[1,] sample0 - as.data.frame(sample0) % % t() % % as.data.frame() data0 - otu_table(phy.lefse) % % as.data.frame() data1 - data0 % % as.data.table(keep.rownames=T) % % t() data2 - rownames_to_column(as.data.frame(data1),var= sample ) pre.lefse - right_join(sample0,data2,by= sample ) % % t() rownames(pre.lefse) - NULL pre.lefse[1,1] - sample pre.lefse[2,1] - IGRA pre.lefse - pre.lefse % % t() % % na.omit() % % t() # write.table(pre.lefse,file =paste(results_folder, lefse.txt ,sep= ),sep = \\t ,row.names = FALSE,col.names = FALSE,quote = FALSE) # opt.class - paste( -c , which(keepvars %in% class)) opt.subclass - ifelse(is.na(subclass), , paste( -s , which(keepvars %in% subclass))) opt.subject - ifelse(is.na(subject), , paste( -u , which(keepvars %in% subject))) format.command - paste(paste( format_input.py ,results_folder, lefse.txt ,results_folder, lefse.in ,sep= ), opt.class, opt.subclass, opt.subject, -o 1000000 ) system(format.command) # #docker run -v ~/Desktop/Charles_MAIT/:/home/linuxbrew/inputs -it biobakery/lefse bash lefse.command - paste(paste( run_lefse.py , lefse.in , lefse.res ,sep= ), -a , anova.alpha, -w , wilcoxon.alpha, -l , lda.cutoff, -e , as.numeric(wilcoxon.within.subclass), -y , as.numeric(one.against.one), -s , mult.test.correction) lefse.command system(lefse.command) lefse.out - read.table(paste( lefse.res ,sep= ), header = FALSE, sep = \\t ) names(lefse.out) -c( taxon , log.max.pct , direction , lda , p.value ) (lefse.out -na.omit(lefse.out)) Palette_LTBI_treatment - c( #377eb8 , #984ea3 ) #modify this ltk -as.character(lefse.out$taxon) phy_ra_ltk -prune_taxa(ltk,phy_contacts) phy_ra_ltk_m -psmelt(phy_ra_ltk) Palette_FC_CC - c( #00C000 , #7F007F ) g2 -ggplot(phy_ra_ltk_m,aes(x=OTU, y=Abundance,color=Group6_TB_category, fill=Group6_TB_category))+ geom_boxplot(position=position_dodge(), colour= black , # Use black outlines, size=.3,alpha=0.5) + # Thinner lines theme_base()+ xlab( )+ coord_flip()+ facet_wrap(~Group6_TB_category) + scale_y_continuous(limits = c(0,15)) if(length(unique(lefse.out$direction)) 3){ g2 -g2+scale_color_manual(values=c(Palette_FC_CC))+ scale_fill_manual(values=c(Palette_FC_CC)) } print(g2) ![abundance_plot](img/MAIT_GD/Correlated_FC-CC_0.01_LDA2.5_all.png) This for loop correlated specifc immune phenotypes (vars_to_keep) with microbiota abundance. It generates a lot of intermediate plots of the individual correlations, but I won't show those. #big for loop mainDir - ~/Desktop/Charles_MAIT/ subDir - DESeq_FC-CC_immune dir.create(file.path(mainDir, subDir), showWarnings = TRUE,recursive = TRUE) results_folder - paste(mainDir,subDir,sep= ) cor_ht_dt - NULL heat_dt - data.frame(taxon = NULL, rho = NULL, effectors = NULL) sample_variables(phy) vars_to_keep - c( il17m_5aru , il17m_dyna , cd4mil17_rest , cd8mil17_rest , dnmil17_rest , cd4mil17_5aru , cd8mil17_5aru , dnmil17_5aru , cd4mil17_dyna , cd8mil17_dyna , dnmil17_dyna , cd4til17_rest , cd8til17_rest , dntil17_rest , cd4til17_dyna , cd8til17_dyna , dntil17_dyna ) effectors_all - c(vars_to_keep) for (effectors in effectors_all){ # Subset the samples phy_var - subset_samples(phy_contacts,!is.na(get_variable(phy_contacts, effectors)) | get_variable(phy_contacts, effectors)!= ) phy_var - subset_samples(phy_var, get_variable(phy_var, effectors) != na ) phy_var - subset_samples(phy_var, get_variable(phy_var, effectors) != ) sdat -otu_table(phy_var) % % as.data.frame() xcor -get_variable(phy_var, effectors) c_th -0.05 c_pvalue -list() c_estimate -list() for (ic in seq(1,nrow(sdat))){ ycor -sdat[ic,] cor.result -cor.test(as.numeric(xcor),as.numeric(ycor),method = spearman ) #nonparametric = spearman c_pvalue[[ic]] - cor.result$p.value c_estimate[[ic]] - cor.result$estimate } c_pvalue -do.call('rbind',c_pvalue) c_estimate -do.call('rbind',c_estimate) isig -which(c_pvalue = c_th) taxa_sig -taxa_names(phy_var)[isig] c_pvalue_sig -c_pvalue[isig] c_estimate_sig -c_estimate[isig] correlation_results -data.frame(taxa_sig,c_pvalue_sig,c_estimate_sig) names(correlation_results) -c( taxon , pvalue , spearman_rho ) if(nrow(correlation_results) 0){ correlation_results$rho -as.numeric(correlation_results$spearman_rho) correlation_results$taxon -factor(correlation_results$taxon, levels=correlation_results$taxon[order(correlation_results$spearman_rho)]) correlation_results$i_eff - effectors # Cut off for rho 0.4 = spearman_rho spearman_rho = -0.4 correlation_results - correlation_results[which(abs(correlation_results$spearman_rho) = 0.2) ,] if(nrow(correlation_results) 0){ cor_ht_dt - rbind(cor_ht_dt, correlation_results) # barplot pdf(paste(results_folder,paste0( bar_plot_spearman_coeff ,effectors, .pdf ),sep= / ),height = 6, width = 10) g1 -ggplot(data=correlation_results,aes(x=taxon, y=rho))+ geom_bar(stat= identity )+ coord_flip()+ theme_base()+ xlab( Species )+ ylab( Spearman - rho ) print(g1) dev.off() # code below is for heatmap phy_sig_var - prune_taxa(as.character(correlation_results$taxon), phy_var) sig_data_c -data.frame(otu_table(phy_sig_var)) y_eff - as.numeric(as.character(get_variable(phy_sig_var, effectors))) pnca_colors -colorRamp2(c(min(log(y_eff+1)), max(log(y_eff+1))), c( white , blue )) dist_to_use -function(x) (1-dist(t(x))) mat -as.matrix(as.data.frame(sig_data_c)) mat2 -scale(t(mat), scale = T, center = T) mat2 -t(mat2) annotations -data.frame(y_eff,as.character(get_variable(phy_var, Group6_TB_category ))) names(annotations) -c( effectors , group )#, conventional_cd8mtreg )#, IGRA )#, group )# cd8mtreg ) # TB_status , IGRA , tmp_c - sample_data(phy_var) % % as.data.frame() #tmp_c[order(tmp_c)$effectors,] #[order(sample_data(phy_var)$effectors),] max_value - max(as.numeric(as.character(get_variable(phy_var, effectors)))) #color_col = list(effectors = colorRamp2(c(0,max_value),c( white , #DC143C )), #group = c( family_contact = #7F007F , community_control = #00C000 )) #color_col = list(effectors = colorRamp2(c(0,noquote(max(tmp_c$effectors))),c( white , #DC143C )), group = c( family_contact = #7F007F , community_control = #00C000 )) #ha_column = HeatmapAnnotation(annotations, col = color_col) ha_column = HeatmapAnnotation(annotations) ht1 = Heatmap(mat2, name = Relative Abundance , column_title = NA, top_annotation = ha_column, clustering_distance_rows = euclidean , clustering_method_rows = complete ,row_names_side = left , km=1, color_space = LAB , col=viridis(11), row_dend_side= right , clustering_method_columns = ward.D , width=4, row_names_max_width = unit(8, cm ),show_column_names= F, row_names_gp = gpar(fontsize = 9), cluster_columns = T,na_col= white ) ht_list = ht1 padding = unit.c(unit(2, mm ), grobWidth(textGrob( jnbksdffsdfsfd_annotation_name )) - unit(1, cm ), unit(c(2, 2), mm )) pdf(paste(results_folder,paste0( heatmap_spearman_0.01_ ,effectors, .pdf ),sep= / ),height = 2.5, width = 11) draw(ht_list, padding = padding) dev.off() } } } # Reshape the dataframe for heatmap cor_ht_dt - cor_ht_dt[,c( taxon , rho , i_eff )] # Convert long to wide format for phyloseq object cor_ht_dt_w - dcast(cor_ht_dt, taxon ~ i_eff, value.var= rho ,fun.aggregate = mean) cor_ht_dt_w[is.na(cor_ht_dt_w)] - 0 ######match tree with heatmap rownames phy_sig -prune_taxa(as.character(cor_ht_dt_w$taxon),phy_contacts) row_den - ape:::as.phylo(phy_tree(phy_sig)) # row_den - as.dendrogram(hclust(dist(cor_data))) # plot(row_den) #r_order - rev(row_den$tip.label) cor_data - cor_ht_dt_w rownames(cor_data) - cor_data$taxon cor_data$taxon - NULL clust.col - hclust(dist(t(cor_data))) plot(clust.col) col_den - as.dendrogram(clust.col) sig_data_c - cor_data mat -as.matrix(sig_data_c) mat2 -scale(t(mat), scale = F, center = F) mat2 -t(mat2) #rownames(mat2) - cor_ht_dt_w$taxon # #get data from ggTree # d - fortify(tr) # dd - subset(d, isTip) # r_order - dd$label[order(dd$y, decreasing=T)] # # mat3 - mat2[match(r_order,rownames(mat2)),] # Without phylogenetic tree clustering sig_data_c - cor_ht_dt_w[,2:ncol(cor_ht_dt_w)] dist_to_use -function(x) (1-dist(t(x))) mat -as.matrix(as.data.frame(sig_data_c)) mat2 -scale(t(mat), scale = F, center = F) mat2 -t(mat2) rownames(mat2) - cor_ht_dt_w$taxon rownames(mat2) - gsub( \\\\s*\\\\w*$ , , rownames(mat2)) jet.colors - colorRampPalette(c( #00007F , blue , #007FFF , cyan , #7FFF7F , yellow , #FF7F00 , red , #7F0000 )) jet.colors - colorRampPalette(c( red , grey , darkblue )) subsets - levels(as.factor(cor_ht_dt$i_eff)) #annotation - data.frame(subsets,c( CD4 , CD4 , CD8 , CD8 , DN , DN , CD4 ),row.names = T) #names(annotation) - c( subset ) #ha_column = HeatmapAnnotation(annotation) pdf(paste(results_folder, /heatmap_spearman_all_effectors_no_tree ,'.pdf',sep= ),height = 20, width = 10) ht1 = Heatmap(mat2, name = relativeAbundance , column_title = NA, #top_annotation = ha_column, #clustering_distance_rows = euclidean ,clustering_method_rows = complete , row_names_side = left , km=1, color_space = LAB , col=jet.colors(11), row_dend_side= right , clustering_method_columns = ward.D ,cluster_rows = F, width=4, row_names_max_width = unit(8, cm ),show_column_names= T, row_names_gp = gpar(fontsize = 9), cluster_columns = T,na_col= white ) ht_list = ht1 draw(ht_list) dev.off() Below is the key output: cor_ht_dt_w$taxon are the taxa that correlate with immune phenotypes, and lefse.out$taxon are the taxa that are differentially abundant between Family Contacts and Community Controls. We intersect these and only look at taxa that are significant for both. common -intersect(lefse.out$taxon,cor_ht_dt_w$taxon) phy_common - prune_taxa(taxa = common,phy_contacts) #Phylogenetic Tree phy_sig -prune_taxa(as.character(cor_ht_dt_w$taxon),phy_contacts) p.species - phy_common library(yingtools2) library(ggtree) tr - phy_tree(p.species) spec - as.data.frame(get.tax(p.species)) gt - ggtree(tr, branch.length = y ,ladderize = T) % +% spec gd - gt$data data_eff - cor_ht_dt_w rownames(data_eff) - cor_ht_dt_w$taxon data_eff$taxon - NULL data_eff - as.matrix(data_eff) #data_eff % % View g1 - gt + geom_tippoint(aes(color=Order),size=3) + geom_tiplab(size =3) # data_eff_cd4 - data_eff[,1:8] # data_eff_cd8 - data_eff[,9:15] g - gheatmap(g1,data_eff,offset=2.5, width=2,colnames_angle=-45,hjust=0,font.size = 5) + scale_fill_gradient2(low = darkred , mid = grey ,high = darkblue )","title":"Clinical variables that explain microbiome differences"},{"location":"MAIT_GD_Tcells/#and-finally-tsne-plots-were-made-with-the-tsnemicrobiota-r-package","text":"#tsne plots library(phyloseq) library(tsnemicrobiota) library(ggplot2) tsne_res - tsne_phyloseq(phy_contacts, distance='jsd', perplexity = 8, verbose=0, rng_seed = 3901,dimensions=3) # Plot the results. #sample_data(phy_contacts)$cd4m_5aru - as.numeric(as.character(sample_data(phy_contacts)$cd4m_5aru)) plot_tsne_phyloseq(phy_contacts, tsne_res, color = 'Group6_TB_category',shape= IGRA , title='t-SNE (jsd)') + geom_point(size=3) + scale_color_manual(values=c(Palette_FC_CC))+ scale_fill_manual(values=c(Palette_FC_CC))","title":"And finally, tsne plots were made with the tsnemicrobiota R package:"},{"location":"Treatment/","text":"HRZE and the gut microbiome This tutorial is a walkthrough of the data analysis from: Antibiotic treatment for Tuberculosis induces a profound dysbiosis of the microbiome that persists long after therapy is completed Scientific Reports 7, Article number: 10767 (2017) doi: 10.1038/s41598-017-10346-6 It shows how to take microbiome data and reproduce the figures from this paper. Part 1: Import 16S uparse output into R I probably have more packages here than I are actually needed to generate the figures in this tutorial, but I have never had a problem loading all of them in this order. One exception is DESeq, which needs to be loaded after the Phyloseq object is constructed. setwd( ~/Desktop/uparse_july/ ) rm(list=ls()) library(plyr);library(ggtree);library(phyloseq);library(ggplot2);library(scales);library(grid) library(Hmisc);library(gridExtra);library(scales);library(stringr);library(logistf) library(coxphf);library(reshape2);library(ifultools);library(car);library(vegan) library(gdata);library(chron);library(data.table);library(tidyr) #imports tibble library(ggplot2);library(yingtools2);library(gridExtra);library(lubridate);library(dplyr) library( pheatmap );library( RColorBrewer );library( genefilter );library(ggthemes) Give priority to specific functions for annoying namespace reasons select - dplyr::select summarize - dplyr::summarize rownames_to_column - tibble::rownames_to_column Necessary uparse pipeline output files for downstream 16S data analysis These are the four files generated from a slightly modified version of the uparse pipeline. The only truly unique file here is the tax.file (repset.fasta.blastn.refseq_rna.txt), which contains information about the top 30 BLASTn hits for each OTU in the seq.file (total.5.repset.fasta). The biom.file (total.8.otu-tax.biom) is a type of data frame where the columns correspond to people and the rows correspond to each OTU from the seq.file. Additionally, this file can hold metadata about either the rows (OTUs) or columns (the people), and in this case, the taxonomy metadata corresponding to the GreenGenes taxonomy names. Finally, the tree.file is generated from a Qiime python script called make_phylogeny.py , which represents true evolutionary distance between these OTU sequences (i.e., the seq.file). These four files generated from uparse, qiime, and blast contain all of the information one needs to accurately analyze microbiome data and generate the types of plots in this tutorial. I make use of many commands from the yingtools2 R package, written by Ying Taur at MSKCC. #edit the $PATH to these files biom.file - ~/Desktop/uparse_july/total.8.otu-tax.biom seq.file - ~/Desktop/uparse_july/total.5.repset.fasta tax.file - ~/Desktop/uparse_july/total.5.repset.fasta.blastn.refseq_rna.txt tree.file - ~/Desktop/uparse_july/total.10.tree biom - import_biom(biom.file) seq - import_qiime(refseqfilename=seq.file) tree - read.tree(text=scan(tree.file,what=character(),quiet=TRUE)) #make tax object with BLAST names (skip this step to assign GreenGenes names instead) tax - yingtools2::read.blastn.file(tax.file) % % set.tax() Import and setup sample data (metadata for each person in the study) data.file - TBRU_Metadata_May2017.csv data - read.csv(data.file,na.strings=c( N/A , 99999 )) % % mutate(sample=gsub( \\\\- , . ,sample)) samp - data % % data.frame() #fix some name issues in the biom file to make sample_names(biom) consistent sample_names(biom) - gsub( ..pool749 , ,sample_names(biom)) sample_names(biom) - gsub( \\034 , ,sample_names(biom)) Merge all data together to create the final phyloseq object phy - merge_phyloseq(biom,seq,tree) tax_table(phy) - tax sample_data(phy) - samp % % set.samp() Part 2: Subset samples and run DESeq data normalization #IGRA positive, only community cohort vs treatment phyIGRA_pos_treatment - subset_samples(phy,!is.na(IGRA) IGRA!= negative ) #can change this first variable to increase contorl sample size by including all IGRA- people, change negative to phyIGRA_pos_treatment - subset_samples(phyIGRA_pos_treatment,!is.na(IGRA) IGRA!= ) phyIGRA_pos_treatment - subset_samples(phyIGRA_pos_treatment,!is.na(TB_status) TB_status!= cured ) phyIGRA_pos_treatment - subset_samples(phyIGRA_pos_treatment,!is.na(TB_status) TB_status!= ) phyIGRA_pos_treatment - subset_samples(phyIGRA_pos_treatment,!is.na(Group6_TB_category) Group6_TB_category!= family_contact ) phyIGRA_pos_treatment - subset_samples(phyIGRA_pos_treatment,age 33) View the Family-level distribution of taxa between the two groups assignCols - function(names,selection) { mymap -list() availableCols -c( #000000 , #FFFF00 , #1CE6FF , #FF34FF , #FF4A46 , #008941 , #006FA6 , #A30059 , #FFDBE5 , #7A4900 , #0000A6 , #63FFAC , #B79762 , #004D43 , #8FB0FF , #997D87 , #5A0007 , #809693 , #FEFFE6 , #1B4400 , #4FC601 , #3B5DFF , #4A3B53 , #FF2F80 , #61615A , #BA0900 , #6B7900 , #00C2A0 , #FFAA92 , #FF90C9 , #B903AA , #D16100 , #DDEFFF , #000035 , #7B4F4B , #A1C299 , #300018 , #0AA6D8 , #013349 , #00846F , #372101 , #FFB500 , #C2FFED , #A079BF , #CC0744 , #C0B9B2 , #C2FF99 , #001E09 , #00489C , #6F0062 , #0CBD66 , #EEC3FF , #456D75 , #B77B68 , #7A87A1 , #788D66 , #885578 , #FAD09F , #FF8A9A , #D157A0 , #BEC459 , #456648 , #0086ED , #886F4C , #34362D , #B4A8BD , #00A6AA , #452C2C , #636375 , #A3C8C9 , #FF913F , #938A81 , #575329 , #00FECF , #B05B6F , #8CD0FF , #3B9700 , #04F757 , #C8A1A1 , #1E6E00 , #7900D7 , #A77500 , #6367A9 , #A05837 , #6B002C , #772600 , #D790FF , #9B9700 , #549E79 , #FFF69F , #201625 , #72418F , #BC23FF , #99ADC0 , #3A2465 , #922329 , #5B4534 , #FDE8DC , #404E55 , #0089A3 , #CB7E98 , #A4E804 , #324E72 , #6A3A4C , #83AB58 , #001C1E , #D1F7CE , #004B28 , #C8D0F6 , #A3A489 , #806C66 , #222800 , #BF5650 , #E83000 , #66796D , #DA007C , #FF1A59 , #8ADBB4 , #1E0200 , #5B4E51 , #C895C5 , #320033 , #FF6832 , #66E1D3 , #CFCDAC , #D0AC94 , #7ED379 , #012C58 ) mymap[[1]] -rev(availableCols[match(intersect(names,selection),names)]) mymap[[2]] -intersect(names,selection) mymap }; #function to make a tax plot faceted by whatever variable plot.tax - function(phyloseq, variable){ t - get.otu.melt(phyIGRA_pos_treatment) % % arrange(Kingdom, Phylum, Class, Order, Family, Genus, Class) % % mutate(TB_status = factor(TB_status,levels = unique(TB_status))) % % group_by(sample) % % arrange(TB_status) % % mutate(cum.pct = cumsum(pctseqs), y.text = (cum.pct + c(0, cum.pct[-length(cum.pct)]))/2) % % ungroup() % % dplyr::select(-cum.pct) g - ggplot() + geom_bar(data = t, aes_string(x = sample , y = pctseqs , fill = Order ), stat = identity ,position = fill ) + theme(legend.position = bottom ) + facet_grid(~TB_status,scales= free ,space= free ) g return(g) } t - get.otu.melt(phyIGRA_pos_treatment) % % arrange(Kingdom, Phylum, Class, Order, Family, Genus, Class) % % mutate(TB_status = factor(TB_status,levels = unique(TB_status))) % % group_by(sample) % % arrange(TB_status) % % mutate(cum.pct = cumsum(pctseqs), y.text = (cum.pct + c(0, cum.pct[-length(cum.pct)]))/2) % % ungroup() % % dplyr::select(-cum.pct) % % as.data.frame() #show the Family level in the plot mycol - assignCols(unique(t$Family),unique(t$Family)) barplot - ggplot() + geom_bar(data = t, aes_string(x = sample , y = pctseqs , fill = Family ),stat = identity ,position = fill ) + facet_grid(~TB_status,scales= free ,space= free ) + theme(legend.position = bottom , axis.title.x=element_blank(),axis.text.x=element_blank(),axis.ticks.x=element_blank()) + theme(legend.text = element_text(size = 14)) + scale_fill_manual(values = mycol[[1]],breaks=mycol[[2]]) barplot Figure 2B from paper Load the DESeq2 package, make taxa names more friendly Downstream plotting of log2 differential abundance data from the DESeq output is made easier when the Species name and the specific OTU number are merged, since multiple OTUs can have the same name library( DESeq2 ) phy_DESeq - phyIGRA_pos_treatment t - get.tax(phy_DESeq) % % mutate(PhySpec=paste(Species,otu)) taxa_names(phy_DESeq) - t$PhySpec taxa_names(phy_DESeq) - gsub( , _ ,taxa_names(phy_DESeq)) taxa_names(phy_DESeq) - gsub( = , _ ,taxa_names(phy_DESeq)) taxa_names(phy_DESeq) - gsub( ; , _ ,taxa_names(phy_DESeq)) Check the variance of OTU abundances This plot tells you that most of the OTUs do not vary much from the raw sequencing data (this is a property of zero inflated data), but some have rather high variance. DESeq will attempt to normalize this variance with respect to a particular sample variable. hist(log10(apply(otu_table(phy_DESeq), 1, var)), xlab = log10(variance) , main = A large fraction of OTUs have very low variance ) Convert the phyloseq object to DESeq object, normalize with respect to TB status, and plot the results dig - phyloseq_to_deseq2(phy_DESeq, ~ TB_status) #replace this with any sample variable(s) #calculate geometric mean gm_mean - function(x, na.rm=TRUE){ exp(sum(log(x[x 0]), na.rm=na.rm) / length(x)) } geoMeans - apply(counts(dig), 1, gm_mean) dig - estimateSizeFactors(dig, geoMeans = geoMeans) dig - estimateDispersions(dig) dig - DESeq(dig,fitType= local ) res - results(dig) #res$pfdr - p.adjust(res$pvalue,method= fdr ) res - res[order(res$padj, na.last=NA), ] alpha - 0.05 sigtab - res[(res$padj alpha), ] sigtab - cbind(as(sigtab, data.frame ), as(tax_table(phy_DESeq)[rownames(sigtab), ], matrix )) head(sigtab) #view the data posigtab - sigtab[sigtab[, log2FoldChange ] 1, ] posigtab - posigtab[, c( baseMean , log2FoldChange , lfcSE , padj , Phylum , Class , Family , Genus )] library( ggplot2 ) theme_set(theme_bw()) sigtabgen - subset(sigtab, !is.na(Genus)) sigtabgen - subset(sigtab, !is.na(Phylum)) #Reorder the data to display the genus x - tapply(sigtabgen$log2FoldChange, sigtabgen$Genus, function(x) max(x)) x - sort(x, TRUE) sigtabgen$Genus - factor(as.character(sigtabgen$Genus), levels=names(x)) phylumcolors - c( hotpink , brown , lightblue , purple ) ggplot(sigtabgen, aes(x = Genus, y = log2FoldChange, color = Phylum)) + geom_point(size = 6) + theme(axis.text.x = element_text(angle = -45, hjust = 0, vjust = 1)) + theme(axis.text=element_text(size=12,face= bold ),legend.text=element_text(size=12)) This plot shows the log2 fold change between IGRA+ people and people on HRZE antibiotic treatment for Tuberculosis. Most of the OTUs fall below zero because they are depleted in people taking antibiotics. Some OTUs are increased however, potentially taking advantage of the altered ecosystem of the gut while taking antibiotics. Part 3: Analyze data with LEfSe LEfSe website: LEfSe Check the $PATH in RStudio to make sure LEfSe Python scripts are there system2( echo ,args = $PATH ) #RStudio should inherit the system path if it is opened at the command line with open -a RStudio #acquire sample data from subsetted phyloseq object and set LEfSe parameters phy.lefse - phy_DESeq results_folder - ~/Desktop/uparse_july/ class - TB_status subclass -FALSE subject - sample anova.alpha -0.05 #this is the important p value wilcoxon.alpha -0.05 lda.cutoff -3.0 wilcoxon.within.subclass - TRUE one.against.one - T mult.test.correction - 0 make.lefse.plots - FALSE by_otus - FALSE # sample.data - phyloseq::sample_data(phy.lefse) % % data.frame(stringsAsFactors = FALSE) sample.data$sample - rownames(sample.data) # keepvars - c( sample , TB_status ) keepvars - unique(keepvars[!is.na(keepvars)]) lefse.samp - sample.data[, keepvars] # sample0 - t(lefse.samp) % % as.matrix() colnames(sample0) - sample0[1,] sample0 - as.data.frame(sample0) # data0 - otu_table(phy.lefse) % % as.data.frame() data1 - data0 % % as.data.table(keep.rownames=T) sample1 - sample0 % % as.data.table(keep.rownames=T) common - intersect(colnames(data1), colnames(sample1)) pre.lefse - rbind(sample1, data1,fill=T) % % t() % % na.omit() % % t() #writes table for LEfSe write.table(pre.lefse,file =paste(results_folder, lefse.txt ,sep= ),sep = \\t ,row.names = FALSE,col.names = FALSE,quote = FALSE) opt.class - paste( -c , which(keepvars %in% class)) opt.subclass - ifelse(is.na(subclass), , paste( -s , which(keepvars %in% subclass))) opt.subject - ifelse(is.na(subject), , paste( -u , which(keepvars %in% subject))) format.command - paste(paste( format_input.py ,results_folder, lefse.txt ,results_folder, lefse.in ,sep= ), opt.class, opt.subject, -o 1000000 ) format.command # format_input.py ~/Desktop/uparse_july/lefse.txt ~/Desktop/uparse_july/lefse.in -c 2 -u 1 -o 1000000 system(format.command) lefse.command - paste(paste( ~/miniconda2/bin/python ~/lefse/run_lefse.py ,results_folder, lefse.in ,results_folder, lefse.res ,sep= ), -a , anova.alpha, -w , wilcoxon.alpha, -l , lda.cutoff, -e , as.numeric(wilcoxon.within.subclass), -y , as.numeric(one.against.one), -s , mult.test.correction) lefse.command # ~/miniconda2/bin/python ~/lefse/run_lefse.py ~/Desktop/uparse_july/lefse.in ~/Desktop/uparse_july/lefse.res -a 0.05 -w 0.05 -l 3 -e 1 -y 1 -s 0 system(lefse.command) #this will print out the number of significant OTUs (make sure it's not 0) lefse.out - read.table(paste(results_folder, lefse.res ,sep= ), header = FALSE, sep = \\t ) names(lefse.out) -c( taxon , log.max.pct , direction , lda , p.value ) (lefse.out -na.omit(lefse.out)) Palette_LTBI_treatment - c( #377eb8 , #984ea3 , pink , blue ) #color palette for plots if(length(unique(lefse.out$direction)) 3){ lefse.out$lda[lefse.out$direction==unique(lefse.out$direction)[1]] - -1*lefse.out$lda[lefse.out$direction==unique(lefse.out$direction)[1]] } lefse.out$taxon -factor(lefse.out$taxon,levels=lefse.out$taxon[order(lefse.out$lda)]) g1 -ggplot(data=lefse.out,aes(x=taxon,y=lda,color=direction,fill=direction))+ geom_bar(stat= identity )+ coord_flip()+ theme_base() if(length(unique(lefse.out$direction)) 3){ g1 -g1+scale_color_manual(values=c(Palette_LTBI_treatment))+ scale_fill_manual(values=c(Palette_LTBI_treatment)) } print(g1) The abscissa shows the linear discriminant analysis (LDA) score for each OTU\u2014a higher score means that the OTU is more important according to LEfSe to discriminate between IGRA+ and HRZE individuals: ltk -as.character(lefse.out$taxon) phy_ra_ltk -prune_taxa(ltk,phy.lefse) phy_ra_ltk_m -psmelt(phy_ra_ltk) phy_ra_ltk_m$OTU -factor(phy_ra_ltk_m$OTU, levels=lefse.out$taxon[order(lefse.out$lda)]) g2 -ggplot(phy_ra_ltk_m,aes(x=OTU, y=Abundance,color=TB_status, fill=TB_status))+ geom_boxplot(position=position_dodge(), colour= black , # Use black outlines, size=.3,alpha=0.5) + # Thinner lines theme_base()+ xlab( )+ coord_flip() + scale_y_continuous(limits = c(0,200)) if(length(unique(lefse.out$direction)) 3){ g2 -g2+scale_color_manual(values=c(Palette_LTBI_treatment))+ scale_fill_manual(values=c(Palette_LTBI_treatment)) } print(g2) Using ggplot's geom_boxplot function, we can plot the most significantly differentially changed OTUs for LTBI vs HRZE people. I left the outliers in just to highlight that they are there, although we removed them for the actual paper for aesthetic purposes: Figure 2D from paper Part 4: Principal Coordinate Analysis phy_ord - ordinate(phyIGRA_pos_treatment, NMDS , bray ) p - plot_ordination(phyIGRA_pos_treatment,phy_ord, color= TB_status ) p + geom_point(size=4) Palette_LTBI_treatment - c( #377eb8 , #984ea3 ) #set the color palette phy_ord - ordinate(phyIGRA_pos_treatment, NMDS , bray ) p - plot_ordination(phyIGRA_pos_treatment,phy_ord, color= TB_status ) p + geom_point(size=4) + theme(legend.text = element_text(size=15), axis.title.x = element_text(size=20), axis.title.y = element_text(size=20), axis.text.x = element_text(size=15), axis.text.y = element_text(size=15)) + scale_colour_manual(values=Palette_LTBI_treatment) The Nonmetric Multidimensional Scaling (NMDS) output does not give traditional PCA % variance values, but is good for count data, and performs well separating people on HRZE and healthy LTBI controls: Figure 2A from paper Part 5: Making a heatmap Heatmaps are my personal favorite way of looking at this type of data. Ideally one would put much more information than just a heatmap into a single figure, but let's start with making a heatmap of just the top 40 most differentially abundant OTUs, and then perform unsupervised hierarchical clustering. rst - varianceStabilizingTransformation(dig, blind=FALSE,fitType = parametric ) sampleDists - dist( t( assay(rst) ) ) sampleDists topVarGenes - head(order(rowVars(assay(rst)),decreasing=TRUE),40) mat - assay(rst)[ topVarGenes, ] mat - mat - rowMeans(mat) rst$days_ON_HRZE - as.numeric(rst$days_ON_HRZE) df - as.data.frame(colData(rst)[,c( TB_status , days_ON_HRZE , age , sex )]) # days_ON_HRZE , TB_status pheatmap(mat, annotation_col=df,clustering_distance_rows = correlation , clustering_method = ward.D2 ,show_colnames = F) Figure 2C from paper Part 6: Making a phylogenetic tree + heatmap People always ask me about individuals on treatment (HRZE) and what effect(s) there are on the Actinobacteria in the microbitoa. Interestingly, the major effects are in the Firmicutes, and as a Phylum, the Actinobacteria are largely untouched, with the exception of a species of Bifidobacterium. The plot below takes the phylogenetic tree of Actinobacteria (generated from make_phylogeny.py) and maps the relative abundance of each OTU on the tree in a heatmap. p_actino - subset_samples(phy,!is.na(IGRA) IGRA!= ) p.species - subset_taxa(p_actino, Phylum== Actinobacteria ) tr - phy_tree(p.species) spec - as.data.frame(get.tax(p.species)) gt - ggtree(tr, branch.length = y ) % +% spec gd - gt$data tt - get.otu.melt(p.species,filter.zero=FALSE)% %left_join(select(gd,otu=label,x,y),by= otu ) % % arrange(TB_status) % % mutate(sample2=factor(sample,levels=unique(sample)), col=as.numeric(sample2),x.col=scales::rescale(col,to=c(1.3,2))) tt$TB_status -factor(tt$TB_status,levels=c( cured , treatment , healthy )) Palette_actino - c( #e7298a , #984ea3 , #377eb8 ) g1 - gt + geom_tippoint(data=gd$istip,aes(color=Genus),size=3) + geom_text(data=gd$istip,aes(label=Genus,x=x+0.001),hjust=-0.1,check_overlap = F) + geom_tile(data=tt,aes(x=x.col,y=y,fill=TB_status,alpha=pctseqs),position= dodge ) + scale_alpha_continuous(trans=log_epsilon_trans(0.00001),aes(show.legend=Relative_Abundance)) + theme(legend.position= right ) g1 + scale_fill_manual(values=Palette_actino) Supplementry Figure from paper","title":"Treatment"},{"location":"Treatment/#hrze-and-the-gut-microbiome","text":"This tutorial is a walkthrough of the data analysis from: Antibiotic treatment for Tuberculosis induces a profound dysbiosis of the microbiome that persists long after therapy is completed Scientific Reports 7, Article number: 10767 (2017) doi: 10.1038/s41598-017-10346-6 It shows how to take microbiome data and reproduce the figures from this paper.","title":"HRZE and the gut microbiome"},{"location":"Treatment/#part-1-import-16s-uparse-output-into-r","text":"I probably have more packages here than I are actually needed to generate the figures in this tutorial, but I have never had a problem loading all of them in this order. One exception is DESeq, which needs to be loaded after the Phyloseq object is constructed. setwd( ~/Desktop/uparse_july/ ) rm(list=ls()) library(plyr);library(ggtree);library(phyloseq);library(ggplot2);library(scales);library(grid) library(Hmisc);library(gridExtra);library(scales);library(stringr);library(logistf) library(coxphf);library(reshape2);library(ifultools);library(car);library(vegan) library(gdata);library(chron);library(data.table);library(tidyr) #imports tibble library(ggplot2);library(yingtools2);library(gridExtra);library(lubridate);library(dplyr) library( pheatmap );library( RColorBrewer );library( genefilter );library(ggthemes)","title":"Part 1: Import 16S uparse output into R"},{"location":"Treatment/#give-priority-to-specific-functions-for-annoying-namespace-reasons","text":"select - dplyr::select summarize - dplyr::summarize rownames_to_column - tibble::rownames_to_column","title":"Give priority to specific functions for annoying namespace reasons"},{"location":"Treatment/#necessary-uparse-pipeline-output-files-for-downstream-16s-data-analysis","text":"These are the four files generated from a slightly modified version of the uparse pipeline. The only truly unique file here is the tax.file (repset.fasta.blastn.refseq_rna.txt), which contains information about the top 30 BLASTn hits for each OTU in the seq.file (total.5.repset.fasta). The biom.file (total.8.otu-tax.biom) is a type of data frame where the columns correspond to people and the rows correspond to each OTU from the seq.file. Additionally, this file can hold metadata about either the rows (OTUs) or columns (the people), and in this case, the taxonomy metadata corresponding to the GreenGenes taxonomy names. Finally, the tree.file is generated from a Qiime python script called make_phylogeny.py , which represents true evolutionary distance between these OTU sequences (i.e., the seq.file). These four files generated from uparse, qiime, and blast contain all of the information one needs to accurately analyze microbiome data and generate the types of plots in this tutorial. I make use of many commands from the yingtools2 R package, written by Ying Taur at MSKCC. #edit the $PATH to these files biom.file - ~/Desktop/uparse_july/total.8.otu-tax.biom seq.file - ~/Desktop/uparse_july/total.5.repset.fasta tax.file - ~/Desktop/uparse_july/total.5.repset.fasta.blastn.refseq_rna.txt tree.file - ~/Desktop/uparse_july/total.10.tree biom - import_biom(biom.file) seq - import_qiime(refseqfilename=seq.file) tree - read.tree(text=scan(tree.file,what=character(),quiet=TRUE)) #make tax object with BLAST names (skip this step to assign GreenGenes names instead) tax - yingtools2::read.blastn.file(tax.file) % % set.tax()","title":"Necessary uparse pipeline output files for downstream 16S data analysis"},{"location":"Treatment/#import-and-setup-sample-data-metadata-for-each-person-in-the-study","text":"data.file - TBRU_Metadata_May2017.csv data - read.csv(data.file,na.strings=c( N/A , 99999 )) % % mutate(sample=gsub( \\\\- , . ,sample)) samp - data % % data.frame() #fix some name issues in the biom file to make sample_names(biom) consistent sample_names(biom) - gsub( ..pool749 , ,sample_names(biom)) sample_names(biom) - gsub( \\034 , ,sample_names(biom))","title":"Import and setup sample data (metadata for each person in the study)"},{"location":"Treatment/#merge-all-data-together-to-create-the-final-phyloseq-object","text":"phy - merge_phyloseq(biom,seq,tree) tax_table(phy) - tax sample_data(phy) - samp % % set.samp()","title":"Merge all data together to create the final phyloseq object"},{"location":"Treatment/#part-2-subset-samples-and-run-deseq-data-normalization","text":"#IGRA positive, only community cohort vs treatment phyIGRA_pos_treatment - subset_samples(phy,!is.na(IGRA) IGRA!= negative ) #can change this first variable to increase contorl sample size by including all IGRA- people, change negative to phyIGRA_pos_treatment - subset_samples(phyIGRA_pos_treatment,!is.na(IGRA) IGRA!= ) phyIGRA_pos_treatment - subset_samples(phyIGRA_pos_treatment,!is.na(TB_status) TB_status!= cured ) phyIGRA_pos_treatment - subset_samples(phyIGRA_pos_treatment,!is.na(TB_status) TB_status!= ) phyIGRA_pos_treatment - subset_samples(phyIGRA_pos_treatment,!is.na(Group6_TB_category) Group6_TB_category!= family_contact ) phyIGRA_pos_treatment - subset_samples(phyIGRA_pos_treatment,age 33)","title":"Part 2: Subset samples and run DESeq data normalization"},{"location":"Treatment/#view-the-family-level-distribution-of-taxa-between-the-two-groups","text":"assignCols - function(names,selection) { mymap -list() availableCols -c( #000000 , #FFFF00 , #1CE6FF , #FF34FF , #FF4A46 , #008941 , #006FA6 , #A30059 , #FFDBE5 , #7A4900 , #0000A6 , #63FFAC , #B79762 , #004D43 , #8FB0FF , #997D87 , #5A0007 , #809693 , #FEFFE6 , #1B4400 , #4FC601 , #3B5DFF , #4A3B53 , #FF2F80 , #61615A , #BA0900 , #6B7900 , #00C2A0 , #FFAA92 , #FF90C9 , #B903AA , #D16100 , #DDEFFF , #000035 , #7B4F4B , #A1C299 , #300018 , #0AA6D8 , #013349 , #00846F , #372101 , #FFB500 , #C2FFED , #A079BF , #CC0744 , #C0B9B2 , #C2FF99 , #001E09 , #00489C , #6F0062 , #0CBD66 , #EEC3FF , #456D75 , #B77B68 , #7A87A1 , #788D66 , #885578 , #FAD09F , #FF8A9A , #D157A0 , #BEC459 , #456648 , #0086ED , #886F4C , #34362D , #B4A8BD , #00A6AA , #452C2C , #636375 , #A3C8C9 , #FF913F , #938A81 , #575329 , #00FECF , #B05B6F , #8CD0FF , #3B9700 , #04F757 , #C8A1A1 , #1E6E00 , #7900D7 , #A77500 , #6367A9 , #A05837 , #6B002C , #772600 , #D790FF , #9B9700 , #549E79 , #FFF69F , #201625 , #72418F , #BC23FF , #99ADC0 , #3A2465 , #922329 , #5B4534 , #FDE8DC , #404E55 , #0089A3 , #CB7E98 , #A4E804 , #324E72 , #6A3A4C , #83AB58 , #001C1E , #D1F7CE , #004B28 , #C8D0F6 , #A3A489 , #806C66 , #222800 , #BF5650 , #E83000 , #66796D , #DA007C , #FF1A59 , #8ADBB4 , #1E0200 , #5B4E51 , #C895C5 , #320033 , #FF6832 , #66E1D3 , #CFCDAC , #D0AC94 , #7ED379 , #012C58 ) mymap[[1]] -rev(availableCols[match(intersect(names,selection),names)]) mymap[[2]] -intersect(names,selection) mymap }; #function to make a tax plot faceted by whatever variable plot.tax - function(phyloseq, variable){ t - get.otu.melt(phyIGRA_pos_treatment) % % arrange(Kingdom, Phylum, Class, Order, Family, Genus, Class) % % mutate(TB_status = factor(TB_status,levels = unique(TB_status))) % % group_by(sample) % % arrange(TB_status) % % mutate(cum.pct = cumsum(pctseqs), y.text = (cum.pct + c(0, cum.pct[-length(cum.pct)]))/2) % % ungroup() % % dplyr::select(-cum.pct) g - ggplot() + geom_bar(data = t, aes_string(x = sample , y = pctseqs , fill = Order ), stat = identity ,position = fill ) + theme(legend.position = bottom ) + facet_grid(~TB_status,scales= free ,space= free ) g return(g) } t - get.otu.melt(phyIGRA_pos_treatment) % % arrange(Kingdom, Phylum, Class, Order, Family, Genus, Class) % % mutate(TB_status = factor(TB_status,levels = unique(TB_status))) % % group_by(sample) % % arrange(TB_status) % % mutate(cum.pct = cumsum(pctseqs), y.text = (cum.pct + c(0, cum.pct[-length(cum.pct)]))/2) % % ungroup() % % dplyr::select(-cum.pct) % % as.data.frame() #show the Family level in the plot mycol - assignCols(unique(t$Family),unique(t$Family)) barplot - ggplot() + geom_bar(data = t, aes_string(x = sample , y = pctseqs , fill = Family ),stat = identity ,position = fill ) + facet_grid(~TB_status,scales= free ,space= free ) + theme(legend.position = bottom , axis.title.x=element_blank(),axis.text.x=element_blank(),axis.ticks.x=element_blank()) + theme(legend.text = element_text(size = 14)) + scale_fill_manual(values = mycol[[1]],breaks=mycol[[2]]) barplot Figure 2B from paper","title":"View the Family-level distribution of taxa between the two groups"},{"location":"Treatment/#load-the-deseq2-package-make-taxa-names-more-friendly","text":"Downstream plotting of log2 differential abundance data from the DESeq output is made easier when the Species name and the specific OTU number are merged, since multiple OTUs can have the same name library( DESeq2 ) phy_DESeq - phyIGRA_pos_treatment t - get.tax(phy_DESeq) % % mutate(PhySpec=paste(Species,otu)) taxa_names(phy_DESeq) - t$PhySpec taxa_names(phy_DESeq) - gsub( , _ ,taxa_names(phy_DESeq)) taxa_names(phy_DESeq) - gsub( = , _ ,taxa_names(phy_DESeq)) taxa_names(phy_DESeq) - gsub( ; , _ ,taxa_names(phy_DESeq))","title":"Load the DESeq2 package, make taxa names more friendly"},{"location":"Treatment/#check-the-variance-of-otu-abundances","text":"This plot tells you that most of the OTUs do not vary much from the raw sequencing data (this is a property of zero inflated data), but some have rather high variance. DESeq will attempt to normalize this variance with respect to a particular sample variable. hist(log10(apply(otu_table(phy_DESeq), 1, var)), xlab = log10(variance) , main = A large fraction of OTUs have very low variance )","title":"Check the variance of OTU abundances"},{"location":"Treatment/#convert-the-phyloseq-object-to-deseq-object-normalize-with-respect-to-tb-status-and-plot-the-results","text":"dig - phyloseq_to_deseq2(phy_DESeq, ~ TB_status) #replace this with any sample variable(s) #calculate geometric mean gm_mean - function(x, na.rm=TRUE){ exp(sum(log(x[x 0]), na.rm=na.rm) / length(x)) } geoMeans - apply(counts(dig), 1, gm_mean) dig - estimateSizeFactors(dig, geoMeans = geoMeans) dig - estimateDispersions(dig) dig - DESeq(dig,fitType= local ) res - results(dig) #res$pfdr - p.adjust(res$pvalue,method= fdr ) res - res[order(res$padj, na.last=NA), ] alpha - 0.05 sigtab - res[(res$padj alpha), ] sigtab - cbind(as(sigtab, data.frame ), as(tax_table(phy_DESeq)[rownames(sigtab), ], matrix )) head(sigtab) #view the data posigtab - sigtab[sigtab[, log2FoldChange ] 1, ] posigtab - posigtab[, c( baseMean , log2FoldChange , lfcSE , padj , Phylum , Class , Family , Genus )] library( ggplot2 ) theme_set(theme_bw()) sigtabgen - subset(sigtab, !is.na(Genus)) sigtabgen - subset(sigtab, !is.na(Phylum)) #Reorder the data to display the genus x - tapply(sigtabgen$log2FoldChange, sigtabgen$Genus, function(x) max(x)) x - sort(x, TRUE) sigtabgen$Genus - factor(as.character(sigtabgen$Genus), levels=names(x)) phylumcolors - c( hotpink , brown , lightblue , purple ) ggplot(sigtabgen, aes(x = Genus, y = log2FoldChange, color = Phylum)) + geom_point(size = 6) + theme(axis.text.x = element_text(angle = -45, hjust = 0, vjust = 1)) + theme(axis.text=element_text(size=12,face= bold ),legend.text=element_text(size=12)) This plot shows the log2 fold change between IGRA+ people and people on HRZE antibiotic treatment for Tuberculosis. Most of the OTUs fall below zero because they are depleted in people taking antibiotics. Some OTUs are increased however, potentially taking advantage of the altered ecosystem of the gut while taking antibiotics.","title":"Convert the phyloseq object to DESeq object, normalize with respect to TB status, and plot the results"},{"location":"Treatment/#part-3-analyze-data-with-lefse","text":"","title":"Part 3: Analyze data with LEfSe"},{"location":"Treatment/#lefse-website-lefse","text":"","title":"LEfSe website: LEfSe"},{"location":"Treatment/#check-the-path-in-rstudio-to-make-sure-lefse-python-scripts-are-there","text":"system2( echo ,args = $PATH ) #RStudio should inherit the system path if it is opened at the command line with open -a RStudio #acquire sample data from subsetted phyloseq object and set LEfSe parameters phy.lefse - phy_DESeq results_folder - ~/Desktop/uparse_july/ class - TB_status subclass -FALSE subject - sample anova.alpha -0.05 #this is the important p value wilcoxon.alpha -0.05 lda.cutoff -3.0 wilcoxon.within.subclass - TRUE one.against.one - T mult.test.correction - 0 make.lefse.plots - FALSE by_otus - FALSE # sample.data - phyloseq::sample_data(phy.lefse) % % data.frame(stringsAsFactors = FALSE) sample.data$sample - rownames(sample.data) # keepvars - c( sample , TB_status ) keepvars - unique(keepvars[!is.na(keepvars)]) lefse.samp - sample.data[, keepvars] # sample0 - t(lefse.samp) % % as.matrix() colnames(sample0) - sample0[1,] sample0 - as.data.frame(sample0) # data0 - otu_table(phy.lefse) % % as.data.frame() data1 - data0 % % as.data.table(keep.rownames=T) sample1 - sample0 % % as.data.table(keep.rownames=T) common - intersect(colnames(data1), colnames(sample1)) pre.lefse - rbind(sample1, data1,fill=T) % % t() % % na.omit() % % t() #writes table for LEfSe write.table(pre.lefse,file =paste(results_folder, lefse.txt ,sep= ),sep = \\t ,row.names = FALSE,col.names = FALSE,quote = FALSE) opt.class - paste( -c , which(keepvars %in% class)) opt.subclass - ifelse(is.na(subclass), , paste( -s , which(keepvars %in% subclass))) opt.subject - ifelse(is.na(subject), , paste( -u , which(keepvars %in% subject))) format.command - paste(paste( format_input.py ,results_folder, lefse.txt ,results_folder, lefse.in ,sep= ), opt.class, opt.subject, -o 1000000 ) format.command # format_input.py ~/Desktop/uparse_july/lefse.txt ~/Desktop/uparse_july/lefse.in -c 2 -u 1 -o 1000000 system(format.command) lefse.command - paste(paste( ~/miniconda2/bin/python ~/lefse/run_lefse.py ,results_folder, lefse.in ,results_folder, lefse.res ,sep= ), -a , anova.alpha, -w , wilcoxon.alpha, -l , lda.cutoff, -e , as.numeric(wilcoxon.within.subclass), -y , as.numeric(one.against.one), -s , mult.test.correction) lefse.command # ~/miniconda2/bin/python ~/lefse/run_lefse.py ~/Desktop/uparse_july/lefse.in ~/Desktop/uparse_july/lefse.res -a 0.05 -w 0.05 -l 3 -e 1 -y 1 -s 0 system(lefse.command) #this will print out the number of significant OTUs (make sure it's not 0) lefse.out - read.table(paste(results_folder, lefse.res ,sep= ), header = FALSE, sep = \\t ) names(lefse.out) -c( taxon , log.max.pct , direction , lda , p.value ) (lefse.out -na.omit(lefse.out)) Palette_LTBI_treatment - c( #377eb8 , #984ea3 , pink , blue ) #color palette for plots if(length(unique(lefse.out$direction)) 3){ lefse.out$lda[lefse.out$direction==unique(lefse.out$direction)[1]] - -1*lefse.out$lda[lefse.out$direction==unique(lefse.out$direction)[1]] } lefse.out$taxon -factor(lefse.out$taxon,levels=lefse.out$taxon[order(lefse.out$lda)]) g1 -ggplot(data=lefse.out,aes(x=taxon,y=lda,color=direction,fill=direction))+ geom_bar(stat= identity )+ coord_flip()+ theme_base() if(length(unique(lefse.out$direction)) 3){ g1 -g1+scale_color_manual(values=c(Palette_LTBI_treatment))+ scale_fill_manual(values=c(Palette_LTBI_treatment)) } print(g1) The abscissa shows the linear discriminant analysis (LDA) score for each OTU\u2014a higher score means that the OTU is more important according to LEfSe to discriminate between IGRA+ and HRZE individuals: ltk -as.character(lefse.out$taxon) phy_ra_ltk -prune_taxa(ltk,phy.lefse) phy_ra_ltk_m -psmelt(phy_ra_ltk) phy_ra_ltk_m$OTU -factor(phy_ra_ltk_m$OTU, levels=lefse.out$taxon[order(lefse.out$lda)]) g2 -ggplot(phy_ra_ltk_m,aes(x=OTU, y=Abundance,color=TB_status, fill=TB_status))+ geom_boxplot(position=position_dodge(), colour= black , # Use black outlines, size=.3,alpha=0.5) + # Thinner lines theme_base()+ xlab( )+ coord_flip() + scale_y_continuous(limits = c(0,200)) if(length(unique(lefse.out$direction)) 3){ g2 -g2+scale_color_manual(values=c(Palette_LTBI_treatment))+ scale_fill_manual(values=c(Palette_LTBI_treatment)) } print(g2) Using ggplot's geom_boxplot function, we can plot the most significantly differentially changed OTUs for LTBI vs HRZE people. I left the outliers in just to highlight that they are there, although we removed them for the actual paper for aesthetic purposes: Figure 2D from paper","title":"Check the $PATH in RStudio to make sure LEfSe Python scripts are there"},{"location":"Treatment/#part-4-principal-coordinate-analysis","text":"phy_ord - ordinate(phyIGRA_pos_treatment, NMDS , bray ) p - plot_ordination(phyIGRA_pos_treatment,phy_ord, color= TB_status ) p + geom_point(size=4) Palette_LTBI_treatment - c( #377eb8 , #984ea3 ) #set the color palette phy_ord - ordinate(phyIGRA_pos_treatment, NMDS , bray ) p - plot_ordination(phyIGRA_pos_treatment,phy_ord, color= TB_status ) p + geom_point(size=4) + theme(legend.text = element_text(size=15), axis.title.x = element_text(size=20), axis.title.y = element_text(size=20), axis.text.x = element_text(size=15), axis.text.y = element_text(size=15)) + scale_colour_manual(values=Palette_LTBI_treatment) The Nonmetric Multidimensional Scaling (NMDS) output does not give traditional PCA % variance values, but is good for count data, and performs well separating people on HRZE and healthy LTBI controls: Figure 2A from paper","title":"Part 4: Principal Coordinate Analysis"},{"location":"Treatment/#part-5-making-a-heatmap","text":"Heatmaps are my personal favorite way of looking at this type of data. Ideally one would put much more information than just a heatmap into a single figure, but let's start with making a heatmap of just the top 40 most differentially abundant OTUs, and then perform unsupervised hierarchical clustering. rst - varianceStabilizingTransformation(dig, blind=FALSE,fitType = parametric ) sampleDists - dist( t( assay(rst) ) ) sampleDists topVarGenes - head(order(rowVars(assay(rst)),decreasing=TRUE),40) mat - assay(rst)[ topVarGenes, ] mat - mat - rowMeans(mat) rst$days_ON_HRZE - as.numeric(rst$days_ON_HRZE) df - as.data.frame(colData(rst)[,c( TB_status , days_ON_HRZE , age , sex )]) # days_ON_HRZE , TB_status pheatmap(mat, annotation_col=df,clustering_distance_rows = correlation , clustering_method = ward.D2 ,show_colnames = F) Figure 2C from paper","title":"Part 5: Making a heatmap"},{"location":"Treatment/#part-6-making-a-phylogenetic-tree-heatmap","text":"People always ask me about individuals on treatment (HRZE) and what effect(s) there are on the Actinobacteria in the microbitoa. Interestingly, the major effects are in the Firmicutes, and as a Phylum, the Actinobacteria are largely untouched, with the exception of a species of Bifidobacterium. The plot below takes the phylogenetic tree of Actinobacteria (generated from make_phylogeny.py) and maps the relative abundance of each OTU on the tree in a heatmap. p_actino - subset_samples(phy,!is.na(IGRA) IGRA!= ) p.species - subset_taxa(p_actino, Phylum== Actinobacteria ) tr - phy_tree(p.species) spec - as.data.frame(get.tax(p.species)) gt - ggtree(tr, branch.length = y ) % +% spec gd - gt$data tt - get.otu.melt(p.species,filter.zero=FALSE)% %left_join(select(gd,otu=label,x,y),by= otu ) % % arrange(TB_status) % % mutate(sample2=factor(sample,levels=unique(sample)), col=as.numeric(sample2),x.col=scales::rescale(col,to=c(1.3,2))) tt$TB_status -factor(tt$TB_status,levels=c( cured , treatment , healthy )) Palette_actino - c( #e7298a , #984ea3 , #377eb8 ) g1 - gt + geom_tippoint(data=gd$istip,aes(color=Genus),size=3) + geom_text(data=gd$istip,aes(label=Genus,x=x+0.001),hjust=-0.1,check_overlap = F) + geom_tile(data=tt,aes(x=x.col,y=y,fill=TB_status,alpha=pctseqs),position= dodge ) + scale_alpha_continuous(trans=log_epsilon_trans(0.00001),aes(show.legend=Relative_Abundance)) + theme(legend.position= right ) g1 + scale_fill_manual(values=Palette_actino) Supplementry Figure from paper","title":"Part 6: Making a phylogenetic tree + heatmap"},{"location":"Treatment_metagenomics/","text":"Loading the data rm (list = ls()) library(phyloseq);library(ggplot2);library(gridExtra);library(RColorBrewer);library(colorspace) library(lattice);library(plyr);library(KEGGREST);library(pracma);library(ggthemes);library(pheatmap) library(ComplexHeatmap);library(BiocParallel);library(genefilter);library(DESeq2);library(tidyr) library(viridis);library(ggstance);library(data.table);library(pracma);library(RbioRXN);library(ggplot2) setwd( ~/Desktop/metagenomics/TBRU_treatment/ ) register(MulticoreParam(30)) asinTransform - function(p) { asin(sqrt(p)) } mainDir - ../metagenomics/ subDir - metaphlan_profiling_treatment dir.create(file.path(mainDir, subDir), showWarnings = TRUE, recursive = TRUE) results_folder - paste(mainDir,subDir,sep= ) mtph_subDir - metaphlan_profiling/ dir.create(file.path(mainDir, mtph_subDir), showWarnings = TRUE, recursive = TRUE) mtph_results_folder - paste(mainDir,mtph_subDir,sep= ) mtph_dat - read.csv( metaphlan2_taxonomic_table_joined.tsv ,sep= \\t ) mtph -mtph_dat rownames(mtph) -mtph$X.SampleID mtph$X.SampleID -NULL mtph_otudata -otu_table(mtph,taxa_are_rows = TRUE) mtph_taxmat - matrix(sample(letters, nrow(mtph_otudata)/10, replace = TRUE), nrow = nrow(mtph_otudata), ncol = 7) rownames(mtph_taxmat) - rownames(mtph_otudata) colnames(mtph_taxmat) - c( Domain , Phylum , Class , Order , Family , Genus , Species ) mtph_taxmat -tax_table(mtph_taxmat) mtph_phy - phyloseq(mtph_otudata, mtph_taxmat) Import the metaphlan data to phyloseq metadata.file - TBRU_Metadata_May2017.csv metadata - read.csv(metadata.file,na.strings=c( N/A , 99999 )) metadata[is.na(metadata)] - 99999 metadata$sample -gsub( - , . ,metadata$sample) samp - metadata % % data.frame() rownames(samp) -metadata$sample snames -as.data.frame(do.call('rbind',strsplit(sample_names(mtph_phy), _ )))[,1] sample_names(mtph_phy) -snames sample_data(mtph_phy) -samp # subsettings mtph_phyIGRA_pos_active - subset_samples(mtph_phy,!is.na(IGRA) IGRA!= ) mtph_phyIGRA_pos_active - subset_samples(mtph_phyIGRA_pos_active,!is.na(Group6_TB_category) Group6_TB_category!= cured ) mtph_phyIGRA_pos_active - subset_samples(mtph_phyIGRA_pos_active,!is.na(Group6_TB_category) Group6_TB_category!= family_contact ) mtph_phyIGRA_pos_active - subset_samples(mtph_phyIGRA_pos_active,!is.na(Group6_TB_category) Group6_TB_category!= family_LTBI ) # keep only 38 years old in age mtph_phyIGRA_pos_active - subset_samples(mtph_phyIGRA_pos_active,age =38) splitted_names_tbru -strsplit(taxa_names(mtph_phyIGRA_pos_active), \\\\| ) splitted_names_tbru_length -lengths(splitted_names_tbru) taxa_names(mtph_phyIGRA_pos_active)[splitted_names_tbru_length==7] mtph_phyIGRA_pos_active.speclevel -prune_taxa(taxa_names(mtph_phyIGRA_pos_active)[splitted_names_tbru_length==7],mtph_phyIGRA_pos_active) taxa_names(mtph_phyIGRA_pos_active.speclevel) -do.call('rbind',strsplit(taxa_names(mtph_phyIGRA_pos_active.speclevel), \\\\| ))[,7] Principle corrdinate analysis pdf(paste(mtph_results_folder,'pca_plot_treatment.pdf',sep= / ),height = 7, width = 10) mtph_GP.ord - ordinate(mtph_phyIGRA_pos_active.speclevel, NMDS , bray ) Palette_LTBI_treatment - c( #377eb8 , #984ea3 ) mtph.p.pca - plot_ordination(mtph_phyIGRA_pos_active.speclevel, mtph_GP.ord, type= samples , color= TB_status ) mtph.p.pca - mtph.p.pca + geom_point(size=4) + theme_base() + scale_color_manual(values=c(Palette_LTBI_treatment)) print(mtph.p.pca) dev.off() assignCols - function(names,selection) { mymap -list() availableCols -c( #000000 , #FFFF00 , #1CE6FF , #FF34FF , #FF4A46 , #008941 , #006FA6 , #A30059 , #FFDBE5 , #7A4900 , #0000A6 , #63FFAC , #B79762 , #004D43 , #8FB0FF , #997D87 , #5A0007 , #809693 , #FEFFE6 , #1B4400 , #4FC601 , #3B5DFF , #4A3B53 , #FF2F80 , #61615A , #BA0900 , #6B7900 , #00C2A0 , #FFAA92 , #FF90C9 , #B903AA , #D16100 , #DDEFFF , #000035 , #7B4F4B , #A1C299 , #300018 , #0AA6D8 , #013349 , #00846F , #372101 , #FFB500 , #C2FFED , #A079BF , #CC0744 , #C0B9B2 , #C2FF99 , #001E09 , #00489C , #6F0062 , #0CBD66 , #EEC3FF , #456D75 , #B77B68 , #7A87A1 , #788D66 , #885578 , #FAD09F , #FF8A9A , #D157A0 , #BEC459 , #456648 , #0086ED , #886F4C , #34362D , #B4A8BD , #00A6AA , #452C2C , #636375 , #A3C8C9 , #FF913F , #938A81 , #575329 , #00FECF , #B05B6F , #8CD0FF , #3B9700 , #04F757 , #C8A1A1 , #1E6E00 , #7900D7 , #A77500 , #6367A9 , #A05837 , #6B002C , #772600 , #D790FF , #9B9700 , #549E79 , #FFF69F , #201625 , #72418F , #BC23FF , #99ADC0 , #3A2465 , #922329 , #5B4534 , #FDE8DC , #404E55 , #0089A3 , #CB7E98 , #A4E804 , #324E72 , #6A3A4C , #83AB58 , #001C1E , #D1F7CE , #004B28 , #C8D0F6 , #A3A489 , #806C66 , #222800 , #BF5650 , #E83000 , #66796D , #DA007C , #FF1A59 , #8ADBB4 , #1E0200 , #5B4E51 , #C895C5 , #320033 , #FF6832 , #66E1D3 , #CFCDAC , #D0AC94 , #7ED379 , #012C58 ) mymap[[1]] -rev(availableCols[match(intersect(names,selection),names)]) mymap[[2]] -intersect(names,selection) mymap }; most_abundant_number -40 topN = most_abundant_number most_abundant_taxa = sort(taxa_sums(mtph_phyIGRA_pos_active.speclevel), TRUE)[1:topN] GP = prune_taxa(names(most_abundant_taxa), mtph_phyIGRA_pos_active.speclevel) mGPr - psmelt(GP) mycol - assignCols(unique(mGPr$OTU),unique(mGPr$OTU)) pdf(paste(results_folder,'barplot_all.pdf',sep= / ),height = 6, width = 14) p.bar -ggplot(data=mGPr,aes(Patient.ID, Abundance, fill=OTU))+ geom_bar(stat = identity ) + theme_base()+ theme(axis.text.x=element_text(angle=90,hjust=1,vjust=0.5)) + scale_fill_manual(values = mycol[[1]],breaks=mycol[[2]]) + facet_wrap(~TB_status, scales= free )+ xlab( ) print(p.bar) dev.off() Run LEfSe on Treatment vs LTBI system( echo $PATH ) # # #aquire sample data from phy phy.lefse -mtph_phyIGRA_pos_active.speclevel class - TB_status subclass -FALSE subject - sample anova.alpha -0.05 wilcoxon.alpha -0.05 lda.cutoff -2.0 wilcoxon.within.subclass - TRUE one.against.one - T mult.test.correction - 0 make.lefse.plots - FALSE by_otus - FALSE # sample.data - sample_data(phy.lefse) % % data.frame(stringsAsFactors = FALSE) rownames(sample.data) - sample.data$sample # keepvars - c( sample , TB_status ) keepvars - unique(keepvars[!is.na(keepvars)]) lefse.samp - sample.data[, keepvars] # sample0 - t(lefse.samp) % % as.matrix() colnames(sample0) - sample0[1,] sample0 - as.data.frame(sample0) # data0 - otu_table(phy.lefse) % % as.data.frame() data1 - data0 % % as.data.table(keep.rownames=T) sample1 - sample0 % % as.data.table(keep.rownames=T) common - intersect(colnames(data1), colnames(sample1)) pre.lefse - rbind(sample1, data1,fill=T) % % t() % % na.omit() % % t() # write.table(pre.lefse,file = paste(results_folder, lefse.txt ,sep= ),sep = \\t ,row.names = FALSE,col.names = FALSE,quote = FALSE) # opt.class - paste( -c , which(keepvars %in% class)) opt.subclass - ifelse(is.na(subclass), , paste( -s , which(keepvars %in% subclass))) opt.subject - ifelse(is.na(subject), , paste( -u , which(keepvars %in% subject))) format.command - paste(paste( format_input.py ,results_folder, lefse.txt ,results_folder, lefse.in ,sep= ), opt.class, opt.subject, -o 1000000 ) system(format.command) # lefse.command - paste(paste( ~/miniconda2/bin/python ~/lefse/run_lefse.py ,results_folder, lefse.in ,results_folder, lefse.res ,sep= ), -a , anova.alpha, -w , wilcoxon.alpha, -l , lda.cutoff, -e , as.numeric(wilcoxon.within.subclass), -y , as.numeric(one.against.one), -s , mult.test.correction) lefse.command system(lefse.command) lefse.out - read.table(paste(results_folder, lefse.res ,sep= ), header = FALSE, sep = \\t ) names(lefse.out) -c( taxon , log.max.pct , direction , lda , p.value ) (lefse.out -na.omit(lefse.out)) pdf(paste(results_folder,'lda_plot_LEFSE.pdf',sep= ),height = 7, width = 10) if(length(unique(lefse.out$direction)) 3){ lefse.out$lda[lefse.out$direction==unique(lefse.out$direction)[1]] - -1*lefse.out$lda[lefse.out$direction==unique(lefse.out$direction)[1]] } lefse.out$taxon -factor(lefse.out$taxon,levels=lefse.out$taxon[order(lefse.out$lda)]) g1 -ggplot(data=lefse.out,aes(x=taxon,y=lda,color=direction,fill=direction))+ geom_bar(stat= identity )+ coord_flip()+ theme_base() if(length(unique(lefse.out$direction)) 3){ g1 -g1+scale_color_manual(values=c(Palette_LTBI_treatment))+ scale_fill_manual(values=c(Palette_LTBI_treatment)) } print(g1) dev.off() print(g1) ltk -as.character(lefse.out$taxon) phy_ra_ltk -prune_taxa(ltk,phy.lefse) phy_ra_ltk_m -psmelt(phy_ra_ltk) phy_ra_ltk_m$OTU -factor(phy_ra_ltk_m$OTU, levels=lefse.out$taxon[order(lefse.out$lda)]) g2 -ggplot(phy_ra_ltk_m,aes(x=OTU, y=Abundance,color=TB_status, fill=TB_status))+ geom_boxplot(position=position_dodge(), colour= black , # Use black outlines, size=.3,alpha=0.5,outlier.shape = NA) + # Thinner lines theme_base()+ xlab( )+ coord_flip()+ scale_y_continuous(limits = c(0,5)) if(length(unique(lefse.out$direction)) 3){ g2 -g2+scale_color_manual(values=c(Palette_LTBI_treatment))+ scale_fill_manual(values=c(Palette_LTBI_treatment)) } print(g2) pdf(paste(results_folder,'significant_LEFSE.cured.pdf',sep= ),height = 6, width = 10) print(g2) dev.off() Make a heatmap with the LEfSe results phy_pos_cured_no_treat_ra_sset_sign -mtph_phy_ra_ltk sig_data_c -otu_table(phy_pos_cured_no_treat_ra_sset_sign) genotype_colors -rep( darkred ,length(sample_data(phy_pos_cured_no_treat_ra_sset_sign)$TB_status)) genotype_colors[which(sample_data(phy_pos_cured_no_treat_ra_sset_sign)$TB_status== healthy )] - darkblue dist.pear -function(x) as.dist(1-cor(t(x))) mat -as.matrix(as.data.frame(sig_data_c)) mat2 -scale(t(mat), scale = TRUE, center = TRUE) mat2 -t(mat2) mat2[mat2==0] -NA annotations -data.frame(sample_data(phy_pos_cured_no_treat_ra_sset_sign)[,c( TB_status )]) names(annotations) -c( TB_status ) color_col = list(TB_status = c( treatment = #984ea3 , healthy = #377eb8 )) ha_column = HeatmapAnnotation(annotations,col = color_col) pdf(paste(results_folder,'in_house_heatmap_pathway_significant_abundance_complex_2.pdf',sep= ),height = 7, width = 10) ht1 - Heatmap(mat2, name = ht1 , column_title = LTBI vs Cured , top_annotation = ha_column, clustering_distance_columns = minkowski , clustering_method_columns = ward.D ,row_names_side = left , km=1, color_space = LAB ,col=magma(11), row_dend_side= right , show_column_names = FALSE , width=4, row_names_max_width = unit(8, cm ), row_names_gp = gpar(fontsize = 9), cluster_columns = T, na_col= white ,heatmap_legend_param = list(at = c(0,5),color_bar = continuous )) ht_list = ht1 padding = unit.c(unit(2, mm ), grobWidth(textGrob( jnbkjsddjdjd_annotation_name )) - unit(1, cm ), unit(c(2, 2), mm )) draw(ht_list, padding = padding) dev.off()","title":"Treatment"},{"location":"Treatment_metagenomics/#loading-the-data","text":"rm (list = ls()) library(phyloseq);library(ggplot2);library(gridExtra);library(RColorBrewer);library(colorspace) library(lattice);library(plyr);library(KEGGREST);library(pracma);library(ggthemes);library(pheatmap) library(ComplexHeatmap);library(BiocParallel);library(genefilter);library(DESeq2);library(tidyr) library(viridis);library(ggstance);library(data.table);library(pracma);library(RbioRXN);library(ggplot2) setwd( ~/Desktop/metagenomics/TBRU_treatment/ ) register(MulticoreParam(30)) asinTransform - function(p) { asin(sqrt(p)) } mainDir - ../metagenomics/ subDir - metaphlan_profiling_treatment dir.create(file.path(mainDir, subDir), showWarnings = TRUE, recursive = TRUE) results_folder - paste(mainDir,subDir,sep= ) mtph_subDir - metaphlan_profiling/ dir.create(file.path(mainDir, mtph_subDir), showWarnings = TRUE, recursive = TRUE) mtph_results_folder - paste(mainDir,mtph_subDir,sep= ) mtph_dat - read.csv( metaphlan2_taxonomic_table_joined.tsv ,sep= \\t ) mtph -mtph_dat rownames(mtph) -mtph$X.SampleID mtph$X.SampleID -NULL mtph_otudata -otu_table(mtph,taxa_are_rows = TRUE) mtph_taxmat - matrix(sample(letters, nrow(mtph_otudata)/10, replace = TRUE), nrow = nrow(mtph_otudata), ncol = 7) rownames(mtph_taxmat) - rownames(mtph_otudata) colnames(mtph_taxmat) - c( Domain , Phylum , Class , Order , Family , Genus , Species ) mtph_taxmat -tax_table(mtph_taxmat) mtph_phy - phyloseq(mtph_otudata, mtph_taxmat)","title":"Loading the data"},{"location":"Treatment_metagenomics/#import-the-metaphlan-data-to-phyloseq","text":"metadata.file - TBRU_Metadata_May2017.csv metadata - read.csv(metadata.file,na.strings=c( N/A , 99999 )) metadata[is.na(metadata)] - 99999 metadata$sample -gsub( - , . ,metadata$sample) samp - metadata % % data.frame() rownames(samp) -metadata$sample snames -as.data.frame(do.call('rbind',strsplit(sample_names(mtph_phy), _ )))[,1] sample_names(mtph_phy) -snames sample_data(mtph_phy) -samp # subsettings mtph_phyIGRA_pos_active - subset_samples(mtph_phy,!is.na(IGRA) IGRA!= ) mtph_phyIGRA_pos_active - subset_samples(mtph_phyIGRA_pos_active,!is.na(Group6_TB_category) Group6_TB_category!= cured ) mtph_phyIGRA_pos_active - subset_samples(mtph_phyIGRA_pos_active,!is.na(Group6_TB_category) Group6_TB_category!= family_contact ) mtph_phyIGRA_pos_active - subset_samples(mtph_phyIGRA_pos_active,!is.na(Group6_TB_category) Group6_TB_category!= family_LTBI ) # keep only 38 years old in age mtph_phyIGRA_pos_active - subset_samples(mtph_phyIGRA_pos_active,age =38) splitted_names_tbru -strsplit(taxa_names(mtph_phyIGRA_pos_active), \\\\| ) splitted_names_tbru_length -lengths(splitted_names_tbru) taxa_names(mtph_phyIGRA_pos_active)[splitted_names_tbru_length==7] mtph_phyIGRA_pos_active.speclevel -prune_taxa(taxa_names(mtph_phyIGRA_pos_active)[splitted_names_tbru_length==7],mtph_phyIGRA_pos_active) taxa_names(mtph_phyIGRA_pos_active.speclevel) -do.call('rbind',strsplit(taxa_names(mtph_phyIGRA_pos_active.speclevel), \\\\| ))[,7]","title":"Import the metaphlan data to phyloseq"},{"location":"Treatment_metagenomics/#principle-corrdinate-analysis","text":"pdf(paste(mtph_results_folder,'pca_plot_treatment.pdf',sep= / ),height = 7, width = 10) mtph_GP.ord - ordinate(mtph_phyIGRA_pos_active.speclevel, NMDS , bray ) Palette_LTBI_treatment - c( #377eb8 , #984ea3 ) mtph.p.pca - plot_ordination(mtph_phyIGRA_pos_active.speclevel, mtph_GP.ord, type= samples , color= TB_status ) mtph.p.pca - mtph.p.pca + geom_point(size=4) + theme_base() + scale_color_manual(values=c(Palette_LTBI_treatment)) print(mtph.p.pca) dev.off() assignCols - function(names,selection) { mymap -list() availableCols -c( #000000 , #FFFF00 , #1CE6FF , #FF34FF , #FF4A46 , #008941 , #006FA6 , #A30059 , #FFDBE5 , #7A4900 , #0000A6 , #63FFAC , #B79762 , #004D43 , #8FB0FF , #997D87 , #5A0007 , #809693 , #FEFFE6 , #1B4400 , #4FC601 , #3B5DFF , #4A3B53 , #FF2F80 , #61615A , #BA0900 , #6B7900 , #00C2A0 , #FFAA92 , #FF90C9 , #B903AA , #D16100 , #DDEFFF , #000035 , #7B4F4B , #A1C299 , #300018 , #0AA6D8 , #013349 , #00846F , #372101 , #FFB500 , #C2FFED , #A079BF , #CC0744 , #C0B9B2 , #C2FF99 , #001E09 , #00489C , #6F0062 , #0CBD66 , #EEC3FF , #456D75 , #B77B68 , #7A87A1 , #788D66 , #885578 , #FAD09F , #FF8A9A , #D157A0 , #BEC459 , #456648 , #0086ED , #886F4C , #34362D , #B4A8BD , #00A6AA , #452C2C , #636375 , #A3C8C9 , #FF913F , #938A81 , #575329 , #00FECF , #B05B6F , #8CD0FF , #3B9700 , #04F757 , #C8A1A1 , #1E6E00 , #7900D7 , #A77500 , #6367A9 , #A05837 , #6B002C , #772600 , #D790FF , #9B9700 , #549E79 , #FFF69F , #201625 , #72418F , #BC23FF , #99ADC0 , #3A2465 , #922329 , #5B4534 , #FDE8DC , #404E55 , #0089A3 , #CB7E98 , #A4E804 , #324E72 , #6A3A4C , #83AB58 , #001C1E , #D1F7CE , #004B28 , #C8D0F6 , #A3A489 , #806C66 , #222800 , #BF5650 , #E83000 , #66796D , #DA007C , #FF1A59 , #8ADBB4 , #1E0200 , #5B4E51 , #C895C5 , #320033 , #FF6832 , #66E1D3 , #CFCDAC , #D0AC94 , #7ED379 , #012C58 ) mymap[[1]] -rev(availableCols[match(intersect(names,selection),names)]) mymap[[2]] -intersect(names,selection) mymap }; most_abundant_number -40 topN = most_abundant_number most_abundant_taxa = sort(taxa_sums(mtph_phyIGRA_pos_active.speclevel), TRUE)[1:topN] GP = prune_taxa(names(most_abundant_taxa), mtph_phyIGRA_pos_active.speclevel) mGPr - psmelt(GP) mycol - assignCols(unique(mGPr$OTU),unique(mGPr$OTU)) pdf(paste(results_folder,'barplot_all.pdf',sep= / ),height = 6, width = 14) p.bar -ggplot(data=mGPr,aes(Patient.ID, Abundance, fill=OTU))+ geom_bar(stat = identity ) + theme_base()+ theme(axis.text.x=element_text(angle=90,hjust=1,vjust=0.5)) + scale_fill_manual(values = mycol[[1]],breaks=mycol[[2]]) + facet_wrap(~TB_status, scales= free )+ xlab( ) print(p.bar) dev.off()","title":"Principle corrdinate analysis"},{"location":"Treatment_metagenomics/#run-lefse-on-treatment-vs-ltbi","text":"system( echo $PATH ) # # #aquire sample data from phy phy.lefse -mtph_phyIGRA_pos_active.speclevel class - TB_status subclass -FALSE subject - sample anova.alpha -0.05 wilcoxon.alpha -0.05 lda.cutoff -2.0 wilcoxon.within.subclass - TRUE one.against.one - T mult.test.correction - 0 make.lefse.plots - FALSE by_otus - FALSE # sample.data - sample_data(phy.lefse) % % data.frame(stringsAsFactors = FALSE) rownames(sample.data) - sample.data$sample # keepvars - c( sample , TB_status ) keepvars - unique(keepvars[!is.na(keepvars)]) lefse.samp - sample.data[, keepvars] # sample0 - t(lefse.samp) % % as.matrix() colnames(sample0) - sample0[1,] sample0 - as.data.frame(sample0) # data0 - otu_table(phy.lefse) % % as.data.frame() data1 - data0 % % as.data.table(keep.rownames=T) sample1 - sample0 % % as.data.table(keep.rownames=T) common - intersect(colnames(data1), colnames(sample1)) pre.lefse - rbind(sample1, data1,fill=T) % % t() % % na.omit() % % t() # write.table(pre.lefse,file = paste(results_folder, lefse.txt ,sep= ),sep = \\t ,row.names = FALSE,col.names = FALSE,quote = FALSE) # opt.class - paste( -c , which(keepvars %in% class)) opt.subclass - ifelse(is.na(subclass), , paste( -s , which(keepvars %in% subclass))) opt.subject - ifelse(is.na(subject), , paste( -u , which(keepvars %in% subject))) format.command - paste(paste( format_input.py ,results_folder, lefse.txt ,results_folder, lefse.in ,sep= ), opt.class, opt.subject, -o 1000000 ) system(format.command) # lefse.command - paste(paste( ~/miniconda2/bin/python ~/lefse/run_lefse.py ,results_folder, lefse.in ,results_folder, lefse.res ,sep= ), -a , anova.alpha, -w , wilcoxon.alpha, -l , lda.cutoff, -e , as.numeric(wilcoxon.within.subclass), -y , as.numeric(one.against.one), -s , mult.test.correction) lefse.command system(lefse.command) lefse.out - read.table(paste(results_folder, lefse.res ,sep= ), header = FALSE, sep = \\t ) names(lefse.out) -c( taxon , log.max.pct , direction , lda , p.value ) (lefse.out -na.omit(lefse.out)) pdf(paste(results_folder,'lda_plot_LEFSE.pdf',sep= ),height = 7, width = 10) if(length(unique(lefse.out$direction)) 3){ lefse.out$lda[lefse.out$direction==unique(lefse.out$direction)[1]] - -1*lefse.out$lda[lefse.out$direction==unique(lefse.out$direction)[1]] } lefse.out$taxon -factor(lefse.out$taxon,levels=lefse.out$taxon[order(lefse.out$lda)]) g1 -ggplot(data=lefse.out,aes(x=taxon,y=lda,color=direction,fill=direction))+ geom_bar(stat= identity )+ coord_flip()+ theme_base() if(length(unique(lefse.out$direction)) 3){ g1 -g1+scale_color_manual(values=c(Palette_LTBI_treatment))+ scale_fill_manual(values=c(Palette_LTBI_treatment)) } print(g1) dev.off() print(g1) ltk -as.character(lefse.out$taxon) phy_ra_ltk -prune_taxa(ltk,phy.lefse) phy_ra_ltk_m -psmelt(phy_ra_ltk) phy_ra_ltk_m$OTU -factor(phy_ra_ltk_m$OTU, levels=lefse.out$taxon[order(lefse.out$lda)]) g2 -ggplot(phy_ra_ltk_m,aes(x=OTU, y=Abundance,color=TB_status, fill=TB_status))+ geom_boxplot(position=position_dodge(), colour= black , # Use black outlines, size=.3,alpha=0.5,outlier.shape = NA) + # Thinner lines theme_base()+ xlab( )+ coord_flip()+ scale_y_continuous(limits = c(0,5)) if(length(unique(lefse.out$direction)) 3){ g2 -g2+scale_color_manual(values=c(Palette_LTBI_treatment))+ scale_fill_manual(values=c(Palette_LTBI_treatment)) } print(g2) pdf(paste(results_folder,'significant_LEFSE.cured.pdf',sep= ),height = 6, width = 10) print(g2) dev.off()","title":"Run LEfSe on Treatment vs LTBI"},{"location":"Treatment_metagenomics/#make-a-heatmap-with-the-lefse-results","text":"phy_pos_cured_no_treat_ra_sset_sign -mtph_phy_ra_ltk sig_data_c -otu_table(phy_pos_cured_no_treat_ra_sset_sign) genotype_colors -rep( darkred ,length(sample_data(phy_pos_cured_no_treat_ra_sset_sign)$TB_status)) genotype_colors[which(sample_data(phy_pos_cured_no_treat_ra_sset_sign)$TB_status== healthy )] - darkblue dist.pear -function(x) as.dist(1-cor(t(x))) mat -as.matrix(as.data.frame(sig_data_c)) mat2 -scale(t(mat), scale = TRUE, center = TRUE) mat2 -t(mat2) mat2[mat2==0] -NA annotations -data.frame(sample_data(phy_pos_cured_no_treat_ra_sset_sign)[,c( TB_status )]) names(annotations) -c( TB_status ) color_col = list(TB_status = c( treatment = #984ea3 , healthy = #377eb8 )) ha_column = HeatmapAnnotation(annotations,col = color_col) pdf(paste(results_folder,'in_house_heatmap_pathway_significant_abundance_complex_2.pdf',sep= ),height = 7, width = 10) ht1 - Heatmap(mat2, name = ht1 , column_title = LTBI vs Cured , top_annotation = ha_column, clustering_distance_columns = minkowski , clustering_method_columns = ward.D ,row_names_side = left , km=1, color_space = LAB ,col=magma(11), row_dend_side= right , show_column_names = FALSE , width=4, row_names_max_width = unit(8, cm ), row_names_gp = gpar(fontsize = 9), cluster_columns = T, na_col= white ,heatmap_legend_param = list(at = c(0,5),color_bar = continuous )) ht_list = ht1 padding = unit.c(unit(2, mm ), grobWidth(textGrob( jnbkjsddjdjd_annotation_name )) - unit(1, cm ), unit(c(2, 2), mm )) draw(ht_list, padding = padding) dev.off()","title":"Make a heatmap with the LEfSe results"},{"location":"about/","text":"","title":"About"},{"location":"uparse/","text":"!/bin/bash vsearch -fastx_filter total.fastq -fastaout total.1.filtered.fasta -fastq_maxee 1 -threads 8 usearch -derep_fulllength total.fasta -fastaout total.2.derep.fasta -sizeout -uc total.2a.derep.uc -threads 8 vsearch -derep_fulllength total.1.filtered.fasta -output total.2.derep.fasta # dereplicate seqs (headers become: pool426.677C.RLP(28).bmt_21;size=38122) # use vsearch instead of usearch (32-bit) for large files. usearch -sortbysize total.2.derep.fasta -minsize 2 -fastaout total.3.sizesorted.fasta # sort by size (by looking at size=xxxx) and remove singletons #usearch -cluster_otus total.3.sizesorted.fasta -otus total.4.repset-raw.fasta -uparseout total.4a.otu-summary.txt -relabel OTU_ -sizein -sizeout usearch -cluster_otus total.3.sizesorted.fasta -otus total.4.repset-raw.fasta -uparseout total.4a.otu-summary.txt -relabel OTU_ -sizein -sizeout # automatically removes de novo chimeras here (usearch7 and above) # provides sequence rep set and otu classification summary # needs to have ';size=xxxx;' from derep step usearch -uchime2_ref total.4.repset-raw.fasta -db ~/Databases/gold.fa -strand plus -nonchimeras total.5.repset.fasta -threads 8 #fasta_number.py total.5.repset-nochimeras.fasta OTU_ total.6.repset.fasta # label OTUs using UPARSE python script: new headers: OTU_ usearch -usearch_global total.fasta -db total.5.repset.fasta -strand plus -id 0.97 -uc total.5a.otu.uc -threads 8 vsearch -usearch_global total.1.filtered.fasta -db total.5.repset.fasta -strand plus -id 0.97 -uc total.5a.otu.uc -threads 8 #map the original quality filtered reads back to OTUs #creates a table showing otu membership (otu.map.uc) #non-matches are reported as 'N' at beginning of line (instead of H) #Some reads may not match any OTU for these reasons: #(1) the read is chimeric, #(2) the read has more than 3% errors, #(3) the read has a singleton sequence so was discarded. python ~/scripts/uc2otutab_mod.py total.5a.otu.uc total.6.otu-table.txt # make OTU table. I modified the function 'GetSampleID' in the script 'uc2otutab.py' and renamed the script 'uc2otutab_mod.py': # The modified function is: function is: # def GetSampleId(Label): # SampleID = Label.split()[0].split('_')[0] # return SampleID biom convert --table-type=\"OTU table\" -i total.6.otu-table.txt -o total.7.otu-table.biom --to-json # convert to biom format # classification, ref=gg99 mothur \"#classify.seqs(fasta=total.5.repset.fasta, taxonomy=/Users/matthewwipperman/Databases/Gg_13_8_99.taxonomy/gg_13_8_99.gg.tax, template=/Users/matthewwipperman/Databases/Gg_13_8_99.taxonomy/gg_13_8_99.fasta, iters=1000, processors=8)\" assign_taxonomy.py -i total.5.repset.fasta -o tax --id_to_taxonomy_fp /Users/matthewwipperman/Databases/Gg_13_8_99.taxonomy/gg_13_8_99.gg.tax --reference_seqs_fp /Users/matthewwipperman/Databases/Gg_13_8_99.taxonomy/gg_13_8_99.fasta --assignment_method mothur --confidence 0 blastn.py total.5.repset.fasta -db refseq_rna # assign taxonomy biom add-metadata --sc-separated taxonomy --observation-header OTUID,taxonomy --observation-metadata-fp tax/total.5.repset_tax_assignments.txt -i total.7.otu-table.biom -o total.8.otu-tax.biom --output-as-json #add taxonomy metadata to biom align_seqs.py -i total.5.repset.fasta -o aligned --template_fp ~/Databases/core_set_aligned.fasta.imputed ##align_seqs.py -i total.5.repset.fasta -o aligned -m muscle filter_alignment.py -i aligned/total.5.repset_aligned.fasta -o aligned make_phylogeny.py -i aligned/total.5.repset_aligned_pfiltered.fasta -o total.10.tree --tree_method fasttree --log_fp aligned/make_phylo.log # create phylogenetic tree #alpha_diversity.py -i total.8.otu-tax.biom -o alpha_diversity.txt -t total.10.tree -m simpson_reciprocal,goods_coverage,observed_species,shannon,simpson,simpson_e,PD_whole_tree,chao1 #beta_diversity.py -i total.8.otu-tax.biom -o beta_diversity -t total.10.tree -m euclidean,binary_euclidean,bray_curtis,bray_curtis_faith,bray_curtis_magurran,manhattan,pearson,spearman_approx,unifrac,unifrac_g,unifrac_g_full_tree,unweighted_unifrac,unweighted_unifrac_full_tree,weighted_normalized_unifrac,weighted_unifrac #calculate alpha and beta diversity send text when done echo 'Now you can make pretty pictures in R :)' | mail -s 'TBRU run complete!' 'matthew.wipperman@gmail.com'","title":"Uparse"},{"location":"uparse/#binbash","text":"vsearch -fastx_filter total.fastq -fastaout total.1.filtered.fasta -fastq_maxee 1 -threads 8","title":"!/bin/bash"},{"location":"uparse/#usearch-derep_fulllength-totalfasta-fastaout-total2derepfasta-sizeout-uc-total2aderepuc-threads-8","text":"vsearch -derep_fulllength total.1.filtered.fasta -output total.2.derep.fasta","title":"usearch -derep_fulllength total.fasta -fastaout total.2.derep.fasta -sizeout -uc total.2a.derep.uc -threads 8"},{"location":"uparse/#dereplicate-seqs-headers-become-pool426677crlp28bmt_21size38122","text":"","title":"# dereplicate seqs (headers become: &gt;pool426.677C.RLP(28).bmt_21;size=38122)"},{"location":"uparse/#use-vsearch-instead-of-usearch-32-bit-for-large-files","text":"","title":"# use vsearch instead of usearch (32-bit) for large files."},{"location":"uparse/#sort-by-size-by-looking-at-sizexxxx-and-remove-singletons","text":"","title":"# sort by size (by looking at size=xxxx) and remove singletons"},{"location":"uparse/#usearch-cluster_otus-total3sizesortedfasta-otus-total4repset-rawfasta-uparseout-total4aotu-summarytxt-relabel-otu_-sizein-sizeout","text":"usearch -cluster_otus total.3.sizesorted.fasta -otus total.4.repset-raw.fasta -uparseout total.4a.otu-summary.txt -relabel OTU_ -sizein -sizeout","title":"#usearch -cluster_otus total.3.sizesorted.fasta -otus total.4.repset-raw.fasta -uparseout total.4a.otu-summary.txt -relabel OTU_ -sizein -sizeout"},{"location":"uparse/#automatically-removes-de-novo-chimeras-here-usearch7-and-above","text":"","title":"# automatically removes de novo chimeras here (usearch7 and above)"},{"location":"uparse/#provides-sequence-rep-set-and-otu-classification-summary","text":"","title":"# provides sequence rep set and otu classification summary"},{"location":"uparse/#needs-to-have-sizexxxx-from-derep-step","text":"","title":"# needs to have ';size=xxxx;' from derep step"},{"location":"uparse/#fasta_numberpy-total5repset-nochimerasfasta-otu_-total6repsetfasta","text":"","title":"#fasta_number.py total.5.repset-nochimeras.fasta OTU_ &gt; total.6.repset.fasta"},{"location":"uparse/#label-otus-using-uparse-python-script-new-headers-otu_","text":"","title":"# label OTUs using UPARSE python script: new headers: OTU_"},{"location":"uparse/#usearch-usearch_global-totalfasta-db-total5repsetfasta-strand-plus-id-097-uc-total5aotuuc-threads-8","text":"vsearch -usearch_global total.1.filtered.fasta -db total.5.repset.fasta -strand plus -id 0.97 -uc total.5a.otu.uc -threads 8","title":"usearch -usearch_global total.fasta -db total.5.repset.fasta -strand plus -id 0.97 -uc total.5a.otu.uc -threads 8"},{"location":"uparse/#map-the-original-quality-filtered-reads-back-to-otus","text":"","title":"#map the original quality filtered reads back to OTUs"},{"location":"uparse/#creates-a-table-showing-otu-membership-otumapuc","text":"","title":"#creates a table showing otu membership (otu.map.uc)"},{"location":"uparse/#non-matches-are-reported-as-n-at-beginning-of-line-instead-of-h","text":"","title":"#non-matches are reported as 'N' at beginning of line (instead of H)"},{"location":"uparse/#some-reads-may-not-match-any-otu-for-these-reasons","text":"","title":"#Some reads may not match any OTU for these reasons:"},{"location":"uparse/#1-the-read-is-chimeric","text":"","title":"#(1) the read is chimeric,"},{"location":"uparse/#2-the-read-has-more-than-3-errors","text":"","title":"#(2) the read has more than 3% errors,"},{"location":"uparse/#3-the-read-has-a-singleton-sequence-so-was-discarded","text":"","title":"#(3) the read has a singleton sequence so was discarded."},{"location":"uparse/#make-otu-table-i-modified-the-function-getsampleid-in-the-script-uc2otutabpy-and-renamed-the-script-uc2otutab_modpy","text":"","title":"# make OTU table. I modified the function 'GetSampleID' in the script 'uc2otutab.py' and renamed the script 'uc2otutab_mod.py':"},{"location":"uparse/#the-modified-function-is-function-is","text":"","title":"# The modified function is: function is:"},{"location":"uparse/#def-getsampleidlabel","text":"","title":"# def GetSampleId(Label):"},{"location":"uparse/#sampleid-labelsplit0split_0","text":"","title":"#    SampleID = Label.split()[0].split('_')[0]"},{"location":"uparse/#return-sampleid","text":"","title":"#    return SampleID"},{"location":"uparse/#convert-to-biom-format","text":"","title":"# convert to biom format"},{"location":"uparse/#classification-refgg99","text":"","title":"# classification, ref=gg99"},{"location":"uparse/#mothur-classifyseqsfastatotal5repsetfasta-taxonomyusersmatthewwippermandatabasesgg_13_8_99taxonomygg_13_8_99ggtax-templateusersmatthewwippermandatabasesgg_13_8_99taxonomygg_13_8_99fasta-iters1000-processors8","text":"assign_taxonomy.py -i total.5.repset.fasta -o tax --id_to_taxonomy_fp /Users/matthewwipperman/Databases/Gg_13_8_99.taxonomy/gg_13_8_99.gg.tax --reference_seqs_fp /Users/matthewwipperman/Databases/Gg_13_8_99.taxonomy/gg_13_8_99.fasta --assignment_method mothur --confidence 0 blastn.py total.5.repset.fasta -db refseq_rna","title":"mothur \"#classify.seqs(fasta=total.5.repset.fasta, taxonomy=/Users/matthewwipperman/Databases/Gg_13_8_99.taxonomy/gg_13_8_99.gg.tax, template=/Users/matthewwipperman/Databases/Gg_13_8_99.taxonomy/gg_13_8_99.fasta, iters=1000, processors=8)\""},{"location":"uparse/#assign-taxonomy","text":"","title":"# assign taxonomy"},{"location":"uparse/#add-taxonomy-metadata-to-biom","text":"","title":"#add taxonomy metadata to biom"},{"location":"uparse/#align_seqspy-i-total5repsetfasta-o-aligned-m-muscle","text":"filter_alignment.py -i aligned/total.5.repset_aligned.fasta -o aligned make_phylogeny.py -i aligned/total.5.repset_aligned_pfiltered.fasta -o total.10.tree --tree_method fasttree --log_fp aligned/make_phylo.log","title":"##align_seqs.py -i total.5.repset.fasta -o aligned -m muscle"},{"location":"uparse/#create-phylogenetic-tree","text":"","title":"# create phylogenetic tree"},{"location":"uparse/#alpha_diversitypy-i-total8otu-taxbiom-o-alpha_diversitytxt-t-total10tree-m-simpson_reciprocalgoods_coverageobserved_speciesshannonsimpsonsimpson_epd_whole_treechao1","text":"","title":"#alpha_diversity.py -i total.8.otu-tax.biom -o alpha_diversity.txt -t total.10.tree -m simpson_reciprocal,goods_coverage,observed_species,shannon,simpson,simpson_e,PD_whole_tree,chao1"},{"location":"uparse/#beta_diversitypy-i-total8otu-taxbiom-o-beta_diversity-t-total10tree-m-euclideanbinary_euclideanbray_curtisbray_curtis_faithbray_curtis_magurranmanhattanpearsonspearman_approxunifracunifrac_gunifrac_g_full_treeunweighted_unifracunweighted_unifrac_full_treeweighted_normalized_unifracweighted_unifrac","text":"","title":"#beta_diversity.py -i total.8.otu-tax.biom -o beta_diversity -t total.10.tree -m euclidean,binary_euclidean,bray_curtis,bray_curtis_faith,bray_curtis_magurran,manhattan,pearson,spearman_approx,unifrac,unifrac_g,unifrac_g_full_tree,unweighted_unifrac,unweighted_unifrac_full_tree,weighted_normalized_unifrac,weighted_unifrac"},{"location":"uparse/#calculate-alpha-and-beta-diversity","text":"","title":"#calculate alpha and beta diversity"},{"location":"uparse/#send-text-when-done","text":"echo 'Now you can make pretty pictures in R :)' | mail -s 'TBRU run complete!' 'matthew.wipperman@gmail.com'","title":"send text when done"},{"location":"uparse_pipeline_June2017/","text":"vsearch -fastx_filter total.fastq -fastaout total.1.filtered.fasta -fastq_maxee 1 -threads 8 vsearch -derep_fulllength total.1.filtered.fasta -output total.2.derep.fasta dereplicate seqs (headers become: pool426.677C.RLP(28).bmt_21;size=38122) use vsearch instead of usearch (32-bit) for large files. usearch -sortbysize total.2.derep.fasta -minsize 2 -fastaout total.3.sizesorted.fasta sort by size (by looking at size=xxxx) and remove singletons usearch -cluster_otus total.3.sizesorted.fasta -otus total.4.repset-raw.fasta -uparseout total.4a.otu-summary.txt -relabel OTU_ -sizein -sizeout automatically removes de novo chimeras here (usearch7 and above); provides sequence rep set and otu classification summary; needs to have ';size=xxxx;' from derep step usearch -uchime2_ref total.4.repset-raw.fasta -db ~/Databases/gold.fa -strand plus -nonchimeras total.5.repset.fasta -threads 8 fasta_number.py total.5.repset-nochimeras.fasta OTU_ total.6.repset.fasta; label OTUs using UPARSE python script: new headers: OTU_### vsearch -usearch_global total.1.filtered.fasta -db total.5.repset.fasta -strand plus -id 0.97 -uc total.5a.otu.uc -threads 8 map the original quality filtered reads back to OTUs; creates a table showing otu membership (otu.map.uc); non-matches are reported as 'N' at beginning of line (instead of H) Some reads may not match any OTU for these reasons: (1) the read is chimeric, (2) the read has more than 3% errors, (3) the read has a singleton sequence so was discarded. python ~/scripts/uc2otutab_mod.py total.5a.otu.uc total.6.otu-table.txt make OTU table. I modified the function 'GetSampleID' in the script 'uc2otutab.py' and renamed the script 'uc2otutab_mod.py': The modified function is: function is: def GetSampleId(Label): SampleID = Label.split()[0].split('_')[0] return SampleID biom convert --table-type=\"OTU table\" -i total.6.otu-table.txt -o total.7.otu-table.biom --to-json convert to biom format mothur \"#classify.seqs(fasta=total.5.repset.fasta, taxonomy=/Users/matthewwipperman/Databases/Gg_13_8_99.taxonomy/gg_13_8_99.gg.tax, template=/Users/matthewwipperman/Databases/Gg_13_8_99.taxonomy/gg_13_8_99.fasta, iters=1000, processors=8)\" assign_taxonomy.py -i total.5.repset.fasta -o tax --id_to_taxonomy_fp /Users/matthewwipperman/Databases/Gg_13_8_99.taxonomy/gg_13_8_99.gg.tax --reference_seqs_fp /Users/matthewwipperman/Databases/Gg_13_8_99.taxonomy/gg_13_8_99.fasta --assignment_method mothur --confidence 0 blastn.py total.5.repset.fasta -db refseq_rna #This is a custom script from Ying Taur at MSKCC biom add-metadata --sc-separated taxonomy --observation-header OTUID,taxonomy --observation-metadata-fp tax/total.5.repset_tax_assignments.txt -i total.7.otu-table.biom -o total.8.otu-tax.biom --output-as-json add taxonomy metadata to biom align_seqs.py -i total.5.repset.fasta -o aligned --template_fp ~/Databases/core_set_aligned.fasta.imputed align_seqs.py -i total.5.repset.fasta -o aligned -m muscle filter_alignment.py -i aligned/total.5.repset_aligned.fasta -o aligned make_phylogeny.py -i aligned/total.5.repset_aligned_pfiltered.fasta -o total.10.tree --tree_method fasttree --log_fp aligned/make_phylo.log create phylogenetic tree alpha_diversity.py -i total.8.otu-tax.biom -o alpha_diversity.txt -t total.10.tree -m simpson_reciprocal,goods_coverage,observed_species,shannon,simpson,simpson_e,PD_whole_tree,chao1 beta_diversity.py -i total.8.otu-tax.biom -o beta_diversity -t total.10.tree -m euclidean,binary_euclidean,bray_curtis,bray_curtis_faith,bray_curtis_magurran,manhattan,pearson,spearman_approx,unifrac,unifrac_g,unifrac_g_full_tree,unweighted_unifrac,unweighted_unifrac_full_tree,weighted_normalized_unifrac,weighted_unifrac calculate alpha and beta diversity send email when done echo 'Now you can make pretty pictures in R :)' | mail -s 'TBRU run complete!' 'matthew.wipperman@gmail.com'","title":"uparse pipeline June2017"},{"location":"uparse_pipeline_June2017/#vsearch-fastx_filter-totalfastq-fastaout-total1filteredfasta-fastq_maxee-1-threads-8","text":"","title":"vsearch -fastx_filter total.fastq -fastaout total.1.filtered.fasta -fastq_maxee 1 -threads 8"},{"location":"uparse_pipeline_June2017/#vsearch-derep_fulllength-total1filteredfasta-output-total2derepfasta","text":"dereplicate seqs (headers become: pool426.677C.RLP(28).bmt_21;size=38122) use vsearch instead of usearch (32-bit) for large files.","title":"vsearch -derep_fulllength total.1.filtered.fasta -output total.2.derep.fasta"},{"location":"uparse_pipeline_June2017/#usearch-sortbysize-total2derepfasta-minsize-2-fastaout-total3sizesortedfasta","text":"sort by size (by looking at size=xxxx) and remove singletons","title":"usearch -sortbysize total.2.derep.fasta -minsize 2 -fastaout total.3.sizesorted.fasta"},{"location":"uparse_pipeline_June2017/#usearch-cluster_otus-total3sizesortedfasta-otus-total4repset-rawfasta-uparseout-total4aotu-summarytxt-relabel-otu_-sizein-sizeout","text":"automatically removes de novo chimeras here (usearch7 and above); provides sequence rep set and otu classification summary; needs to have ';size=xxxx;' from derep step","title":"usearch -cluster_otus total.3.sizesorted.fasta -otus total.4.repset-raw.fasta -uparseout total.4a.otu-summary.txt -relabel OTU_ -sizein -sizeout"},{"location":"uparse_pipeline_June2017/#usearch-uchime2_ref-total4repset-rawfasta-db-databasesgoldfa-strand-plus-nonchimeras-total5repsetfasta-threads-8","text":"fasta_number.py total.5.repset-nochimeras.fasta OTU_ total.6.repset.fasta; label OTUs using UPARSE python script: new headers: OTU_###","title":"usearch -uchime2_ref total.4.repset-raw.fasta -db ~/Databases/gold.fa -strand plus -nonchimeras total.5.repset.fasta -threads 8"},{"location":"uparse_pipeline_June2017/#vsearch-usearch_global-total1filteredfasta-db-total5repsetfasta-strand-plus-id-097-uc-total5aotuuc-threads-8","text":"map the original quality filtered reads back to OTUs; creates a table showing otu membership (otu.map.uc); non-matches are reported as 'N' at beginning of line (instead of H) Some reads may not match any OTU for these reasons: (1) the read is chimeric, (2) the read has more than 3% errors, (3) the read has a singleton sequence so was discarded.","title":"vsearch -usearch_global total.1.filtered.fasta -db total.5.repset.fasta -strand plus -id 0.97 -uc total.5a.otu.uc -threads 8"},{"location":"uparse_pipeline_June2017/#python-scriptsuc2otutab_modpy-total5aotuuc-total6otu-tabletxt","text":"make OTU table. I modified the function 'GetSampleID' in the script 'uc2otutab.py' and renamed the script 'uc2otutab_mod.py': The modified function is: function is: def GetSampleId(Label): SampleID = Label.split()[0].split('_')[0] return SampleID","title":"python ~/scripts/uc2otutab_mod.py total.5a.otu.uc &gt; total.6.otu-table.txt"},{"location":"uparse_pipeline_June2017/#biom-convert-table-typeotu-table-i-total6otu-tabletxt-o-total7otu-tablebiom-to-json","text":"convert to biom format","title":"biom convert --table-type=\"OTU table\" -i total.6.otu-table.txt -o total.7.otu-table.biom --to-json"},{"location":"uparse_pipeline_June2017/#mothur-classifyseqsfastatotal5repsetfasta-taxonomyusersmatthewwippermandatabasesgg_13_8_99taxonomygg_13_8_99ggtax-templateusersmatthewwippermandatabasesgg_13_8_99taxonomygg_13_8_99fasta-iters1000-processors8","text":"","title":"mothur \"#classify.seqs(fasta=total.5.repset.fasta, taxonomy=/Users/matthewwipperman/Databases/Gg_13_8_99.taxonomy/gg_13_8_99.gg.tax, template=/Users/matthewwipperman/Databases/Gg_13_8_99.taxonomy/gg_13_8_99.fasta, iters=1000, processors=8)\""},{"location":"uparse_pipeline_June2017/#assign_taxonomypy-i-total5repsetfasta-o-tax-id_to_taxonomy_fp-usersmatthewwippermandatabasesgg_13_8_99taxonomygg_13_8_99ggtax-reference_seqs_fp-usersmatthewwippermandatabasesgg_13_8_99taxonomygg_13_8_99fasta-assignment_method-mothur-confidence-0","text":"","title":"assign_taxonomy.py -i total.5.repset.fasta -o tax --id_to_taxonomy_fp /Users/matthewwipperman/Databases/Gg_13_8_99.taxonomy/gg_13_8_99.gg.tax --reference_seqs_fp /Users/matthewwipperman/Databases/Gg_13_8_99.taxonomy/gg_13_8_99.fasta --assignment_method mothur --confidence 0"},{"location":"uparse_pipeline_June2017/#blastnpy-total5repsetfasta-db-refseq_rna-this-is-a-custom-script-from-ying-taur-at-mskcc","text":"","title":"blastn.py total.5.repset.fasta -db refseq_rna #This is a custom script from Ying Taur at MSKCC"},{"location":"uparse_pipeline_June2017/#biom-add-metadata-sc-separated-taxonomy-observation-header-otuidtaxonomy-observation-metadata-fp-taxtotal5repset_tax_assignmentstxt-i-total7otu-tablebiom-o-total8otu-taxbiom-output-as-json","text":"add taxonomy metadata to biom","title":"biom add-metadata --sc-separated taxonomy --observation-header OTUID,taxonomy --observation-metadata-fp tax/total.5.repset_tax_assignments.txt -i total.7.otu-table.biom -o total.8.otu-tax.biom --output-as-json"},{"location":"uparse_pipeline_June2017/#align_seqspy-i-total5repsetfasta-o-aligned-template_fp-databasescore_set_alignedfastaimputed","text":"","title":"align_seqs.py -i total.5.repset.fasta -o aligned --template_fp ~/Databases/core_set_aligned.fasta.imputed"},{"location":"uparse_pipeline_June2017/#align_seqspy-i-total5repsetfasta-o-aligned-m-muscle","text":"","title":"align_seqs.py -i total.5.repset.fasta -o aligned -m muscle"},{"location":"uparse_pipeline_June2017/#filter_alignmentpy-i-alignedtotal5repset_alignedfasta-o-aligned","text":"","title":"filter_alignment.py -i aligned/total.5.repset_aligned.fasta -o aligned"},{"location":"uparse_pipeline_June2017/#make_phylogenypy-i-alignedtotal5repset_aligned_pfilteredfasta-o-total10tree-tree_method-fasttree-log_fp-alignedmake_phylolog","text":"create phylogenetic tree","title":"make_phylogeny.py -i aligned/total.5.repset_aligned_pfiltered.fasta -o total.10.tree --tree_method fasttree --log_fp aligned/make_phylo.log"},{"location":"uparse_pipeline_June2017/#alpha_diversitypy-i-total8otu-taxbiom-o-alpha_diversitytxt-t-total10tree-m-simpson_reciprocalgoods_coverageobserved_speciesshannonsimpsonsimpson_epd_whole_treechao1","text":"","title":"alpha_diversity.py -i total.8.otu-tax.biom -o alpha_diversity.txt -t total.10.tree -m simpson_reciprocal,goods_coverage,observed_species,shannon,simpson,simpson_e,PD_whole_tree,chao1"},{"location":"uparse_pipeline_June2017/#beta_diversitypy-i-total8otu-taxbiom-o-beta_diversity-t-total10tree-m-euclideanbinary_euclideanbray_curtisbray_curtis_faithbray_curtis_magurranmanhattanpearsonspearman_approxunifracunifrac_gunifrac_g_full_treeunweighted_unifracunweighted_unifrac_full_treeweighted_normalized_unifracweighted_unifrac","text":"calculate alpha and beta diversity","title":"beta_diversity.py -i total.8.otu-tax.biom -o beta_diversity -t total.10.tree -m euclidean,binary_euclidean,bray_curtis,bray_curtis_faith,bray_curtis_magurran,manhattan,pearson,spearman_approx,unifrac,unifrac_g,unifrac_g_full_tree,unweighted_unifrac,unweighted_unifrac_full_tree,weighted_normalized_unifrac,weighted_unifrac"},{"location":"uparse_pipeline_June2017/#send-email-when-done","text":"","title":"send email when done"},{"location":"uparse_pipeline_June2017/#echo-now-you-can-make-pretty-pictures-in-r-mail-s-tbru-run-complete-matthewwippermangmailcom","text":"","title":"echo 'Now you can make pretty pictures in R :)' | mail -s 'TBRU run complete!' 'matthew.wipperman@gmail.com'"}]}